binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
trialData$objectZ <- ifelse(end[3] > -300, 270, 350)
graspData <- rbind(graspData, trialData)
}
ggplot(data = graspData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
facet_grid(. ~ objectZ) +
coord_fixed()
ggplot(data = graspData) +
geom_point(aes(thuDist, indexZ), color = "red") +
geom_point(aes(thuDist, thumbZ), color = "blue") +
facet_grid(. ~ objectZ)
ggplot(data = graspData) +
geom_point(aes(-thuDist, indexZ), color = "red") +
geom_point(aes(-thuDist, thumbZ), color = "blue") +
facet_grid(. ~ objectZ)
ggplot(data = graspData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
facet_grid(. ~ objectZ) +
coord_fixed()
setwd("P:/### LABS ###/Domini-ShapeLab/carlo/2012-2013/dataExpOct")
setwd("P:/### LABS ###/Domini-ShapeLab/carlo/2012-2013/dataExpOct/")
Data <- read.table("gData.txt", header=TRUE)
head(Data)
unique(Data$subjN)
library(kinesis)
usefCols <- c("trialN","indexXraw","indexYraw","indexZraw","thumbXraw","thumbYraw","thumbZraw")
options(scipen = 1, digits = 3)
libraries()
library(cowplot)
testData <- data.check(rtgData_bad[usefCols])
graspData <- NULL
for(tN in unique(testData$trialN))
{
cat("---- trial #", tN, ". ----\n\n")
# trial
testTrial <- subset(testData, trialN == tN)
# signals analysis
start <- c(267,-332,-11.5)
kmData <- testTrial[c("thumbXraw","thumbYraw","thumbZraw","time")]
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
end <- as.numeric(km.res[km.res$moment=="end",1:3])
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate)
# merge back
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
# crop out the inbound portion of trajectory
returnVel_threshold <- -100
# crop return
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
# set offset time based on vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
trialData$objectZ <- ifelse(end[3] > -300, 270, 350)
graspData <- rbind(graspData, trialData)
}
unique(graspData$trialN)
unique(testData$trialN)
testData <- data.check(rtgData_bad[usefCols])
testData
rtgData_bad[usefCols]
testData <- data.check(rtgData_bad[usefCols])
library(kinesis)
testData <- data.check(rtgData_bad[usefCols])
graspData <- NULL
for(tN in unique(testData$trialN))
{
cat("---- trial #", tN, ". ----\n\n")
# trial
testTrial <- subset(testData, trialN == tN)
# signals analysis
start <- c(267,-332,-11.5)
kmData <- testTrial[c("thumbXraw","thumbYraw","thumbZraw","time")]
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
end <- as.numeric(km.res[km.res$moment=="end",1:3])
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate)
# merge back
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
# crop out the inbound portion of trajectory
returnVel_threshold <- -100
# crop return
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
# set offset time based on vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
trialData$objectZ <- ifelse(end[3] > -300, 270, 350)
graspData <- rbind(graspData, trialData)
}
unique(graspData$trialN)
ggplot(data = graspData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
facet_grid(. ~ objectZ) +
coord_fixed()
data.check.test <- function(dataset, refreshRate = 85, time.unit = 1, ...)
{
# assign refreshRate & time.unit to global environment for looping inside ddply (temporary)
assign("refreshRate", refreshRate, envir = .GlobalEnv)
assign("time.unit", time.unit, envir = .GlobalEnv)
reqCols <- c("subjName","frameN", "time","deltaTime")
missingCols <- reqCols[!reqCols %in% names(dataset)]
if (length(missingCols) > 0) {
cat("The following columns do not exist:\n")
cat(missingCols, sep = ", ")
cat("\n\nFixing...\n\n")
# Fix subjName
if ("subjName" %in% missingCols) {
cat("Please type subject name:\n")
dataset$subjName <- readline()
cat("subjName added.\n")
}
# Fix frameN
if ("frameN" %in% missingCols) {
dataset <- kin.frameN(dataset)
cat("frameN added.\n")
}
# Fix frameT
if ("deltaTime" %in% missingCols) {
# if time does not exists, create deltaTime
if("time" %in% missingCols){
dataset <- ddply(dataset, .(trialN), mutate,
frameT = time.unit / refreshRate)
} else {
# else deltaTime is delta time
dataset <- ddply(dataset, .(trialN), mutate,
frameT = c(NA, diff(time)))
}
cat("deltaTime added.\n")
}
# Fix time
if ("time" %in% missingCols) {
dataset <- kin.time(dataset, refreshRate, time.unit)
cat("time added.\n")
}
cat("\nDatabase fixed successfully.")
}
else {
cat("\nDatabase looks good.")
}
# remove refreshRate & time.unit from global environment
remove(refreshRate, envir = .GlobalEnv)
remove(time.unit, envir = .GlobalEnv)
return(dataset)
}
data.check.test(rtgData_bad)
theme_set
library(kinesis)
library(kinesis)
library(kinesis)
library(kinesis)
library("kinesis", lib.loc="~/R/win-library/3.4")
detach("package:kinesis", unload=TRUE)
library("kinesis", lib.loc="~/R/win-library/3.4")
detach("package:kinesis", unload=TRUE)
devtools::document()
library(kinesis)
library(kinesis)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
library(kinesis)
library(kinesis)
library(kinesis)
options(scipen = 1, digits = 3)
library(kinesis)
library(cowplot)
usefCols <- c("trialN","indexXraw","indexYraw","indexZraw","thumbXraw","thumbYraw","thumbZraw")
testData <- data.check(rtgData_bad[usefCols])
testTrial <- subset(testData, trialN == 50)
max(testTrial$framesOccluded)
testTrial$indexXrep <- with(testTrial, kin.signal.repair(indexXraw, maxFrames= 20))
testTrial$indexYrep <- with(testTrial, kin.signal.repair(indexYraw, maxFrames= 20))
testTrial$indexZrep <- with(testTrial, kin.signal.repair(indexZraw, maxFrames= 20))
testTrial$thumbXrep <- with(testTrial, kin.signal.repair(thumbXraw, maxFrames= 20))
testTrial$thumbYrep <- with(testTrial, kin.signal.repair(thumbYraw, maxFrames= 20))
testTrial$thumbZrep <- with(testTrial, kin.signal.repair(thumbZraw, maxFrames= 20))
testTrial$indexXsg <- with(testTrial, kin.sgFilter(indexXrep, ts = 1/85))
testTrial$indexYsg <- with(testTrial, kin.sgFilter(indexYrep, ts = 1/85))
testTrial$indexZsg <- with(testTrial, kin.sgFilter(indexZrep, ts = 1/85))
testTrial$thumbXsg <- with(testTrial, kin.sgFilter(thumbXrep, ts = 1/85))
testTrial$thumbYsg <- with(testTrial, kin.sgFilter(thumbYrep, ts = 1/85))
testTrial$thumbZsg <- with(testTrial, kin.sgFilter(thumbZrep, ts = 1/85))
testTrial$indexX <- testTrial$indexXsg
testTrial$indexY <- testTrial$indexYsg
testTrial$indexZ <- testTrial$indexZsg
testTrial$thumbX <- testTrial$thumbXsg
testTrial$thumbY <- testTrial$thumbYsg
testTrial$thumbZ <- testTrial$thumbZsg
indData.backup <- testTrial[,c("indexX","indexY","indexZ")]
thuData.backup <- testTrial[,c("thumbX","thumbY","thumbZ")]
rotData.backup <- rbind(indData.backup, setNames(thuData.backup, names(indData.backup)))
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
rotData <- rotData.backup - transData[rep(1, nrow(rotData.backup)),]
indData <- indData.backup - transData[rep(1, nrow(indData.backup)),]
thuData <- thuData.backup - transData[rep(1, nrow(thuData.backup)),]
end <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
indData <- kin.rotate.trajectory(indData, end)
thuData <- kin.rotate.trajectory(thuData, end)
library(kinesis)
indData <- kin.rotate.trajectory(indData, end)
thuData <- kin.rotate.trajectory(thuData, end)
indData <- as.data.frame(indData)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData)
names(thuData) <- c("thumbX","thumbY","thumbZ")
names(indData) <- paste(names(indData), "rot", sep="")
names(thuData) <- paste(names(thuData), "rot", sep="")
testTrial <- cbind(testTrial, indData, thuData)
testTrial$indexX <- testTrial$indexXrot
testTrial$indexY <- testTrial$indexYrot
testTrial$indexZ <- testTrial$indexZrot
testTrial$thumbX <- testTrial$thumbXrot
testTrial$thumbY <- testTrial$thumbYrot
testTrial$thumbZ <- testTrial$thumbZrot
testTrial$thumbXvel <- with(testTrial, kin.sgFilter(thumbX,m=1, ts = 1/85))
testTrial$thumbYvel <- with(testTrial, kin.sgFilter(thumbY,m=1, ts = 1/85))
testTrial$thumbZvel <- with(testTrial, kin.sgFilter(thumbZ,m=1, ts = 1/85))
testTrial$thumbVel <- with(testTrial, sqrt(thumbXvel^2 + thumbYvel^2 + thumbZvel^2)) # in mm/s
testTrial$indexXvel <- with(testTrial, kin.sgFilter(indexX,m=1, ts = 1/85))
testTrial$indexYvel <- with(testTrial, kin.sgFilter(indexY,m=1, ts = 1/85))
testTrial$indexZvel <- with(testTrial, kin.sgFilter(indexZ,m=1, ts = 1/85))
testTrial$indexVel <- with(testTrial, sqrt(indexXvel^2 + indexYvel^2 + indexZvel^2)) # in mm/s
testTrial$indexVel <- with(testTrial, kin.sgFilter(indexVel, ts = 1/85))
testTrial$thumbVel <- with(testTrial, kin.sgFilter(thumbVel, ts = 1/85))
testTrial$indexAcc <- with(testTrial, kin.sgFilter(indexVel, m=1, ts = 1/85))
testTrial$thumbAcc <- with(testTrial, kin.sgFilter(thumbVel, m=1, ts = 1/85))
testTrial$indexAcc <- with(testTrial, kin.sgFilter(indexAcc, p = 12, ts = 1/85))
testTrial$thumbAcc <- with(testTrial, kin.sgFilter(thumbAcc, p = 12, ts = 1/85))
testTrial$indexJerk <- with(testTrial, kin.sgFilter(indexAcc, m=1, ts = 1/85))
testTrial$thumbJerk <- with(testTrial, kin.sgFilter(thumbAcc, m=1, ts = 1/85))
testTrial$indexJerk <- with(testTrial, kin.sgFilter(indexJerk, p = 12, ts = 1/85))
testTrial$thumbJerk <- with(testTrial, kin.sgFilter(thumbJerk, p = 12, ts = 1/85))
testTrial.backup <- testTrial
return_threshold <- -100
testTrial <- subset(testTrial.backup, thumbZvel > return_threshold & indexZvel > return_threshold)
onset_threshold <- 100
onsetFrame <- kin.find.onsetTime(testTrial$thumbVel, onset_threshold)
testTrial$onsetTime <- testTrial$time[testTrial$frameN == onsetFrame]
testTrial <- subset(testTrial, frameN >= onsetFrame)
testTrial$thumbVelAccJerk.res <- with(testTrial, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
testTrial$indexVelAccJerk.res <- with(testTrial, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
testTrial$index_thumbVelAccJerk.res <- with(testTrial, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
offsetFrame <- with(testTrial, frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
testTrial$offsetTime <- testTrial$time[testTrial$frameN == offsetFrame]
testTrial <- subset(testTrial, frameN <= offsetFrame)
library(kinesis)
library(kinesis)
library(kinesis)
options(scipen = 1, digits = 3)
library(cowplot)
# PROCEDURE FROM GALLIVAN and CHAPMAN 2014
#### Prepare the dataset ####
# keep only useful columns
usefCols <- c("trialN","indexXraw","indexYraw","indexZraw","thumbXraw","thumbYraw","thumbZraw")
# Fix dataset
testData <- data.check(rtgData_bad[usefCols])
#### 1. individual trial analysis ####
###  1.1 extract ROI ----
##   1.1.1 fill in missing frames ----
# inpaint_nans function in matlab
# select one trial with missing frames
testTrial <- subset(testData, trialN == 50)
# testTrial <- subset(testData, trialN == badTrialNum)
# plot the data
# ggplot(aes(frameN, thumbXraw), data = testTrial) + geom_point() # thumb data is bad
# repair missing frames
testTrial$indexXrep <- with(testTrial, kin.signal.repair(indexXraw, maxFrames= 20))
testTrial$indexYrep <- with(testTrial, kin.signal.repair(indexYraw, maxFrames= 20))
testTrial$indexZrep <- with(testTrial, kin.signal.repair(indexZraw, maxFrames= 20))
testTrial$thumbXrep <- with(testTrial, kin.signal.repair(thumbXraw, maxFrames= 20))
testTrial$thumbYrep <- with(testTrial, kin.signal.repair(thumbYraw, maxFrames= 20))
testTrial$thumbZrep <- with(testTrial, kin.signal.repair(thumbZraw, maxFrames= 20))
# thumb data fixed
# ggplot(aes(frameN, thumbXrep, color = fingersOccluded), data = testTrial) + geom_point()
##   1.1.2 filter ----
#    1.1.2.1 butterworth filter ----
# dual pass, 8–12 Hz cutoff, 2nd order
# testTrial$indexXbw <- with(testTrial, kin.bwFilter(indexXrep, cutoff_freq = 10, type = "pass"))
# testTrial$indexYbw <- with(testTrial, kin.bwFilter(indexYrep, cutoff_freq = 10, type = "pass"))
# testTrial$indexZbw <- with(testTrial, kin.bwFilter(indexZrep, cutoff_freq = 10, type = "pass"))
#
# testTrial$thumbXbw <- with(testTrial, kin.bwFilter(thumbXrep, cutoff_freq = 10, type = "pass"))
# testTrial$thumbYbw <- with(testTrial, kin.bwFilter(thumbYrep, cutoff_freq = 10, type = "pass"))
# testTrial$thumbZbw <- with(testTrial, kin.bwFilter(thumbZrep, cutoff_freq = 10, type = "pass"))
# ggplot(data = testTrial) +
#   geom_point(aes(frameN, thumbXrep), color = "black") +
#   geom_point(aes(frameN, thumbXbw), color = "red", alpha=.5)
#    1.1.2.2 Savitzky-Golay filter ----
# 3rd order
testTrial$indexXsg <- with(testTrial, kin.sgFilter(indexXrep, ts = 1/85))
testTrial$indexYsg <- with(testTrial, kin.sgFilter(indexYrep, ts = 1/85))
testTrial$indexZsg <- with(testTrial, kin.sgFilter(indexZrep, ts = 1/85))
testTrial$thumbXsg <- with(testTrial, kin.sgFilter(thumbXrep, ts = 1/85))
testTrial$thumbYsg <- with(testTrial, kin.sgFilter(thumbYrep, ts = 1/85))
testTrial$thumbZsg <- with(testTrial, kin.sgFilter(thumbZrep, ts = 1/85))
# ggplot(data = testTrial) +
#   geom_point(aes(frameN, thumbXrep), color = "black") +
#   geom_point(aes(frameN, thumbXsg), color = "green", alpha=.5)
#    1.2.2.3 choose filter and apply ----
# savitzky-golay filter is less distorting than butterworth (less variable residuals)
# qplot(indexXbw-indexXrep, indexXsg-indexXrep, data=testTrial, geom="point") + coord_fixed()
# qplot(thumbXbw-thumbXrep, thumbXsg-thumbXrep, data=testTrial, geom="point") + coord_fixed()
testTrial$indexX <- testTrial$indexXsg
testTrial$indexY <- testTrial$indexYsg
testTrial$indexZ <- testTrial$indexZsg
testTrial$thumbX <- testTrial$thumbXsg
testTrial$thumbY <- testTrial$thumbYsg
testTrial$thumbZ <- testTrial$thumbZsg
##   1.1.3 translate and rotate to have all trajectories going in the same direction ----
# the trajectory is assumed to start at origin (0,0,0)
# and terminate at a point (0,0,z)
# with x axis: rightwards positive, leftwards negative
#      y axis: upwards positive, downwards negative
#      z axis: forwards positive, backwards negative
# this requires a translation followed by a rotation
# starting dataset to apply translations and rotations on recursively
indData.backup <- testTrial[,c("indexX","indexY","indexZ")]
thuData.backup <- testTrial[,c("thumbX","thumbY","thumbZ")]
# dataset containing to-be-rotated fingers positions
rotData.backup <- rbind(indData.backup, setNames(thuData.backup, names(indData.backup)))
# define start and end of movement
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
# CASE 1: whole grasp
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
rotData <- rotData.backup - transData[rep(1, nrow(rotData.backup)),]
indData <- indData.backup - transData[rep(1, nrow(indData.backup)),]
thuData <- thuData.backup - transData[rep(1, nrow(thuData.backup)),]
# end coordinates of the whole grasp
end <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData <- kin.rotate.trajectory(indData, end)
thuData <- kin.rotate.trajectory(thuData, end)
# polish rotated dataset
indData <- as.data.frame(indData)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData)
names(thuData) <- c("thumbX","thumbY","thumbZ")
# merge rotated data and apply rotation
names(indData) <- paste(names(indData), "rot", sep="")
names(thuData) <- paste(names(thuData), "rot", sep="")
testTrial <- cbind(testTrial, indData, thuData)
testTrial$indexX <- testTrial$indexXrot
testTrial$indexY <- testTrial$indexYrot
testTrial$indexZ <- testTrial$indexZrot
testTrial$thumbX <- testTrial$thumbXrot
testTrial$thumbY <- testTrial$thumbYrot
testTrial$thumbZ <- testTrial$thumbZrot
##   1.1.4 find movement onset ----
#    1.1.4.1 calculate velocity vector ----
# using Savitzy-Golay filter (remember the frame rate!!)
testTrial$thumbXvel <- with(testTrial, kin.sgFilter(thumbX,m=1, ts = 1/85))
testTrial$thumbYvel <- with(testTrial, kin.sgFilter(thumbY,m=1, ts = 1/85))
testTrial$thumbZvel <- with(testTrial, kin.sgFilter(thumbZ,m=1, ts = 1/85))
testTrial$thumbVel <- with(testTrial, sqrt(thumbXvel^2 + thumbYvel^2 + thumbZvel^2)) # in mm/s
# using Savitzy-Golay filter (remember the frame rate!!)
testTrial$indexXvel <- with(testTrial, kin.sgFilter(indexX,m=1, ts = 1/85))
testTrial$indexYvel <- with(testTrial, kin.sgFilter(indexY,m=1, ts = 1/85))
testTrial$indexZvel <- with(testTrial, kin.sgFilter(indexZ,m=1, ts = 1/85))
testTrial$indexVel <- with(testTrial, sqrt(indexXvel^2 + indexYvel^2 + indexZvel^2)) # in mm/s
#    1.1.4.2 Savitzky-Golay filter velocitiy, acceleration and jerk vectors ----
# 3rd order
# filter velocity
testTrial$indexVel <- with(testTrial, kin.sgFilter(indexVel, ts = 1/85))
testTrial$thumbVel <- with(testTrial, kin.sgFilter(thumbVel, ts = 1/85))
# derive acceleration
testTrial$indexAcc <- with(testTrial, kin.sgFilter(indexVel, m=1, ts = 1/85))
testTrial$thumbAcc <- with(testTrial, kin.sgFilter(thumbVel, m=1, ts = 1/85))
# filter acceleration
testTrial$indexAcc <- with(testTrial, kin.sgFilter(indexAcc, p = 12, ts = 1/85))
testTrial$thumbAcc <- with(testTrial, kin.sgFilter(thumbAcc, p = 12, ts = 1/85))
# derive jerk
testTrial$indexJerk <- with(testTrial, kin.sgFilter(indexAcc, m=1, ts = 1/85))
testTrial$thumbJerk <- with(testTrial, kin.sgFilter(thumbAcc, m=1, ts = 1/85))
# filter jerk
testTrial$indexJerk <- with(testTrial, kin.sgFilter(indexJerk, p = 12, ts = 1/85))
testTrial$thumbJerk <- with(testTrial, kin.sgFilter(thumbJerk, p = 12, ts = 1/85))
#    1.1.4.3 find onset time ----
# crop out the inbound portion of trajectory
testTrial.backup <- testTrial
return_threshold <- -100
testTrial <- subset(testTrial.backup, thumbZvel > return_threshold & indexZvel > return_threshold)
# flag trajectory where z velocity is > threshold
# incrementally count frames where the condition is met
# the longest string is the winner, take its fist frame as zero
onset_threshold <- 100
onsetFrame <- kin.find.onsetTime(testTrial$thumbVel, onset_threshold)
# time at movement onset
testTrial$onsetTime <- testTrial$time[testTrial$frameN == onsetFrame]
# crop out trajectory before onset
testTrial <- subset(testTrial, frameN >= onsetFrame)
#    1.1.4.4 find offset time ----
# in case there is no exact offset time, offset time is defined differently depending on the movement
# in the case of grasping, it is defined as the time at which velocity, acceleration and jerk of index and thumb reach a minimum
# resultant vectors
testTrial$thumbVelAccJerk.res <- with(testTrial, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
testTrial$indexVelAccJerk.res <- with(testTrial, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
testTrial$index_thumbVelAccJerk.res <- with(testTrial, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
offsetFrame <- with(testTrial, frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
testTrial$offsetTime <- testTrial$time[testTrial$frameN == offsetFrame]
# crop out trajectory after offset
testTrial <- subset(testTrial, frameN <= offsetFrame)
testTrial.backup1 <- testTrial
keepCols <- c("trialN","indexX","indexY","indexZ","thumbX","thumbY","thumbZ",
"subjName","frameN","frameT","time",
"indexVel","indexAcc","thumbVel","thumbAcc")
testTrial <- testTrial.backup1[keepCols]
ggplot(data = testTrial) +
geom_point(aes(time, thumbZ), color = "blue") +
geom_point(aes(time, indexZ), color = "red")
keepCols <- c("trialN","indexX","indexY","indexZ","thumbX","thumbY","thumbZ",
"subjName","frameN","deltaTime","time",
"indexVel","indexAcc","thumbVel","thumbAcc")
testTrial <- testTrial.backup1[keepCols]
ggplot(data = testTrial) +
geom_point(aes(time, thumbZ), color = "blue") +
geom_point(aes(time, indexZ), color = "red")
testTrial$thuDist <- sqrt((testTrial$thumbX - tail(testTrial$thumbX, 1))^2 +
(testTrial$thumbY - tail(testTrial$thumbY, 1))^2 +
(testTrial$thumbZ - tail(testTrial$thumbZ, 1))^2
)
binN <- 100
testTrial$thuDistB <- with(testTrial, cut(thuDist, breaks = binN, labels = F))
head(testTrial)
curvatureData.ind <- testTrial[c("indexX","indexY","indexZ")]
head(testTrial.backup1)
curvatureData.ind <- testTrial[c("indexX","indexY","indexZ")]
curvatureData.ind$indexXvel <- with(curvatureData.ind, kin.sgFilter(indexX,m=1, ts = 1/85))
curvatureData.ind$indexYvel <- with(curvatureData.ind, kin.sgFilter(indexY,m=1, ts = 1/85))
curvatureData.ind$indexZvel <- with(curvatureData.ind, kin.sgFilter(indexZ,m=1, ts = 1/85))
curvatureData.ind$indexXacc <- with(curvatureData.ind, kin.sgFilter(indexX,m=2, ts = 1/85))
curvatureData.ind$indexYacc <- with(curvatureData.ind, kin.sgFilter(indexY,m=2, ts = 1/85))
curvatureData.ind$indexZacc <- with(curvatureData.ind, kin.sgFilter(indexZ,m=2, ts = 1/85))
