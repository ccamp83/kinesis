# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
# polish rotated dataset
data <- as.data.frame(data)
names(data) <- c("indexX","indexY","indexZ")
# thuData <- as.data.frame(thuData.m)
# names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(data[c(1,3,2)], col="red")
# points3d(data[c(1,3,2)], col="blue")
end <- end.ind
# if data is not a matrix, convert to matrix
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
# three-steps rotation in 3D
for(plane in c("f","t","s"))
{
# form the couples relative to each projection plane
# frontoparallel plane (x,y) | trasversal plane (x,z) | sagittal plane (z,y)
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
# compute angles
# theta <- atan(endCoord.y/endCoord.x)
theta <- atan2(endCoord.y, endCoord.x)
# theta[theta<0] <- theta[theta<0] + 2*pi
theta <- theta
cat(theta*180/pi,"\n")
# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
# polish rotated dataset
data <- as.data.frame(data)
names(data) <- c("indexX","indexY","indexZ")
# thuData <- as.data.frame(thuData.m)
# names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(data[c(1,3,2)], col="red")
# points3d(data[c(1,3,2)], col="blue")
end <- end.ind
# if data is not a matrix, convert to matrix
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
# three-steps rotation in 3D
for(plane in c("f","t","s"))
{
# form the couples relative to each projection plane
# frontoparallel plane (x,y) | trasversal plane (x,z) | sagittal plane (z,y)
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
# compute angles
# theta <- atan(endCoord.y/endCoord.x)
theta <- atan2(endCoord.y, endCoord.x)
theta[theta<0] <- theta[theta<0] + pi
theta <- theta
cat(theta*180/pi,"\n")
# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
# polish rotated dataset
data <- as.data.frame(data)
names(data) <- c("indexX","indexY","indexZ")
# thuData <- as.data.frame(thuData.m)
# names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(data[c(1,3,2)], col="red")
# points3d(data[c(1,3,2)], col="blue")
theta
end <- end.ind
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
theta <- atan2(endCoord.y, endCoord.x)
cat(theta*180/pi,"\n")
90-136
end <- end.ind
# if data is not a matrix, convert to matrix
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
# three-steps rotation in 3D
for(plane in c("f","t","s"))
{
# form the couples relative to each projection plane
# frontoparallel plane (x,y) | trasversal plane (x,z) | sagittal plane (z,y)
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
# compute angles
# theta <- atan(endCoord.y/endCoord.x)
theta <- atan2(endCoord.y, endCoord.x)
theta[theta<0] <- theta[theta<0] + 2*pi
theta <- pi/2 - theta
cat(theta*180/pi,"\n")
# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
# polish rotated dataset
data <- as.data.frame(data)
names(data) <- c("indexX","indexY","indexZ")
# thuData <- as.data.frame(thuData.m)
# names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(data[c(1,3,2)], col="red")
# points3d(data[c(1,3,2)], col="blue")
end <- end.ind
# if data is not a matrix, convert to matrix
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
# three-steps rotation in 3D
for(plane in c("f","t","s"))
{
# form the couples relative to each projection plane
# frontoparallel plane (x,y) | trasversal plane (x,z) | sagittal plane (z,y)
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
# compute angles
# theta <- atan(endCoord.y/endCoord.x)
theta <- atan2(endCoord.y, endCoord.x)
theta[theta<0] <- theta[theta<0] + 2*pi
theta <- pi/2 + theta
cat(theta*180/pi,"\n")
# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
# polish rotated dataset
data <- as.data.frame(data)
names(data) <- c("indexX","indexY","indexZ")
# thuData <- as.data.frame(thuData.m)
# names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(data[c(1,3,2)], col="red")
# points3d(data[c(1,3,2)], col="blue")
end <- end.ind
# if data is not a matrix, convert to matrix
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
# three-steps rotation in 3D
for(plane in c("f","t","s"))
{
# form the couples relative to each projection plane
# frontoparallel plane (x,y) | trasversal plane (x,z) | sagittal plane (z,y)
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
# compute angles
# theta <- atan(endCoord.y/endCoord.x)
theta <- atan2(endCoord.y, endCoord.x)
theta[theta<0] <- theta[theta<0] + 2*pi
theta <- 3*pi/2 + theta
cat(theta*180/pi,"\n")
# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
# polish rotated dataset
data <- as.data.frame(data)
names(data) <- c("indexX","indexY","indexZ")
# thuData <- as.data.frame(thuData.m)
# names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(data[c(1,3,2)], col="red")
# points3d(data[c(1,3,2)], col="blue")
theta <- theta  + c(0, 3*pi/2, 0)
end <- end.ind
# if data is not a matrix, convert to matrix
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
# three-steps rotation in 3D
for(plane in c("f","t","s"))
{
# form the couples relative to each projection plane
# frontoparallel plane (x,y) | trasversal plane (x,z) | sagittal plane (z,y)
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
# compute angles
# theta <- atan(endCoord.y/endCoord.x)
theta <- atan2(endCoord.y, endCoord.x)
theta[theta<0] <- theta[theta<0] + 2*pi
theta <- theta  + c(0, 3*pi/2, 0)
cat(theta*180/pi,"\n")
# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
# polish rotated dataset
data <- as.data.frame(data)
names(data) <- c("indexX","indexY","indexZ")
# thuData <- as.data.frame(thuData.m)
# names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(data[c(1,3,2)], col="red")
# points3d(data[c(1,3,2)], col="blue")
end <- end.ind
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
for(plane in c("f","t","s"))
{
# form the couples relative to each projection plane
# frontoparallel plane (x,y) | trasversal plane (x,z) | sagittal plane (z,y)
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
# compute angles
# theta <- atan(endCoord.y/endCoord.x)
theta <- atan2(endCoord.y, endCoord.x)
theta[theta<0] <- theta[theta<0] + 2*pi
theta <- theta  + c(0, 3*pi/2, 0)
cat(theta*180/pi,"\n")
# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
data <- as.data.frame(data)
names(data) <- c("indexX","indexY","indexZ")
plot3d(rotData[c(1,3,2)])
points3d(data[c(1,3,2)], col="red")
end <- end.ind
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
theta <- atan2(endCoord.y, endCoord.x)
cat(theta*180/pi,"\n")
theta[theta<0] <- theta[theta<0] + 2*pi
cat(theta*180/pi,"\n")
end <- end.ind
# if data is not a matrix, convert to matrix
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
# three-steps rotation in 3D
for(plane in c("f","t","s"))
{
# form the couples relative to each projection plane
# frontoparallel plane (x,y) | trasversal plane (x,z) | sagittal plane (z,y)
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
# compute angles
# theta <- atan(endCoord.y/endCoord.x)
theta <- atan2(endCoord.y, endCoord.x)
theta[theta<0] <- theta[theta<0] + 2*pi
theta <- theta * c(0, -1, 0)
cat(theta*180/pi,"\n")
# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
# polish rotated dataset
data <- as.data.frame(data)
names(data) <- c("indexX","indexY","indexZ")
# thuData <- as.data.frame(thuData.m)
# names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(data[c(1,3,2)], col="red")
# points3d(data[c(1,3,2)], col="blue")
end <- end.ind
# if data is not a matrix, convert to matrix
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
# three-steps rotation in 3D
for(plane in c("f","t","s"))
{
# form the couples relative to each projection plane
# frontoparallel plane (x,y) | trasversal plane (x,z) | sagittal plane (z,y)
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
# compute angles
# theta <- atan(endCoord.y/endCoord.x)
theta <- atan2(endCoord.y, endCoord.x)
theta[theta<0] <- theta[theta<0] + 2*pi
theta <- theta * c(1, -1, 1)
cat(theta*180/pi,"\n")
# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
# polish rotated dataset
data <- as.data.frame(data)
names(data) <- c("indexX","indexY","indexZ")
# thuData <- as.data.frame(thuData.m)
# names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(data[c(1,3,2)], col="red")
# points3d(data[c(1,3,2)], col="blue")
indData <- indData.backup - transData[rep(1, nrow(indData.backup)),]
# end coordinates of the whole grasp
end.ind <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# --- THUMB
kmData <- cbind(thuData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
thuData <- thuData.backup - transData[rep(1, nrow(thuData.backup)),]
# end coordinates of the whole grasp
end.thu <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData.m <- kin.rotate.trajectory(indData, end.ind)
thuData.m <- kin.rotate.trajectory(thuData, end.thu)
# polish rotated dataset
indData <- as.data.frame(indData.m)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData.m)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
end <- end.ind
# if data is not a matrix, convert to matrix
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
theta <- atan2(endCoord.y, endCoord.x)
cat(theta*180/pi,"\n")
end <- end.ind
# if data is not a matrix, convert to matrix
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
# three-steps rotation in 3D
for(plane in c("f","t","s"))
{
# form the couples relative to each projection plane
# frontoparallel plane (x,y) | trasversal plane (x,z) | sagittal plane (z,y)
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
# compute angles
# theta <- atan(endCoord.y/endCoord.x)
theta <- atan2(endCoord.y, endCoord.x)
theta[theta<0] <- theta[theta<0] + 2*pi
theta <- - theta + pi/2
cat(theta*180/pi,"\n")
# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
# polish rotated dataset
data <- as.data.frame(data)
names(data) <- c("indexX","indexY","indexZ")
# thuData <- as.data.frame(thuData.m)
# names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(data[c(1,3,2)], col="red")
# points3d(data[c(1,3,2)], col="blue")
end <- end.ind
# if data is not a matrix, convert to matrix
if(!is.matrix(indData))
{
data = as.matrix(indData)
}
# three-steps rotation in 3D
for(plane in c("f","t","s"))
{
# form the couples relative to each projection plane
# frontoparallel plane (x,y) | trasversal plane (x,z) | sagittal plane (z,y)
endCoord.x <- c(end[1], end[1], end[3])
endCoord.y <- c(end[2], end[3], end[2])
# compute angles
# theta <- atan(endCoord.y/endCoord.x)
theta <- atan2(endCoord.y, endCoord.x)
theta[theta<0] <- pi - theta[theta<0]
# theta <- - theta + pi/2
cat(theta*180/pi,"\n")
# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
# polish rotated dataset
data <- as.data.frame(data)
names(data) <- c("indexX","indexY","indexZ")
# thuData <- as.data.frame(thuData.m)
# names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(data[c(1,3,2)], col="red")
# points3d(data[c(1,3,2)], col="blue")
