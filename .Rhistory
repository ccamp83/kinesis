testTrial <- subset(testTrial.backup, thumbZvel > return_threshold & indexZvel > return_threshold)
onset_threshold <- 50
onsetFrame <- kin.find.onsetTime(testTrial$thumbZvel, onset_threshold)
testTrial$time[testTrial$frameN == onsetFrame]
testTrial$time <- testTrial$time - onsetTime
onset_threshold <- 50
onsetFrame <- kin.find.onsetTime(testTrial$thumbVel, onset_threshold)
testTrial$time[testTrial$frameN == onsetFrame]
testTrial$time <- testTrial$time - onsetTime
testTrial <- subset(testTrial, time >= 0)
ggplot(data = testTrial) +
geom_point(aes(time, thumbXvel), color = "red") +
geom_point(aes(time, thumbYvel), color = "darkgreen") +
geom_point(aes(time, thumbZvel), color = "blue") +
geom_point(aes(time, thumbVel), color = "black") +
geom_hline(yintercept = 50)
testTrial <- subset(testTrial.backup, thumbZvel > return_threshold & indexZvel > return_threshold)
ggplot(data = testTrial) +
geom_point(aes(time, thumbXvel), color = "red") +
geom_point(aes(time, thumbYvel), color = "darkgreen") +
geom_point(aes(time, thumbZvel), color = "blue") +
geom_point(aes(time, thumbVel), color = "black") +
geom_hline(yintercept = 50)
onset_threshold <- 50
onsetFrame <- kin.find.onsetTime(testTrial$thumbVel, onset_threshold)
onsetFrame
testTrial$time[testTrial$frameN == onsetFrame]
testTrial
testTrial$time[testTrial$frameN == onsetFrame]
testTrial$time <- testTrial$time - onsetTime
ggplot(data = testTrial) +
geom_point(aes(time, thumbXvel), color = "red") +
geom_point(aes(time, thumbYvel), color = "darkgreen") +
geom_point(aes(time, thumbZvel), color = "blue") +
geom_point(aes(time, thumbVel), color = "black") +
geom_hline(yintercept = 50)
testTrial <- subset(testTrial, time >= 0)
ggplot(data = testTrial) +
geom_point(aes(time, thumbXvel), color = "red") +
geom_point(aes(time, thumbYvel), color = "darkgreen") +
geom_point(aes(time, thumbZvel), color = "blue") +
geom_point(aes(time, thumbVel), color = "black") +
geom_hline(yintercept = 50)
rm(list = ls())
options(scipen = 1, digits = 3)
libraries()
library(cowplot)
# PROCEDURE FROM GALLIVAN and CHAPMAN 2014
#### Prepare the dataset ####
# keep only useful columns
usefCols <- c("trialN","indexXraw","indexYraw","indexZraw","thumbXraw","thumbYraw","thumbZraw")
# Fix dataset
testData <- data.check(rtgData_bad[usefCols])
test
# is there missing data for each digit in this dataset?
any(testData$fingersOccluded==1) # YES
#### 1. individual trial analysis ####
###  1.1 extract ROI ----
##   1.1.1 fill in missing frames ----
# inpaint_nans function in matlab
# select one trial with missing frames
# flag trials with missing frames
testData <- ddply(testData, .(trialN), mutate,
missing.frames = any(framesOccluded > 0))
# extract these trials number
trial.na.frame <- unique(subset(testData, missing.frames)$trialN)
# pick a random bad trial
badTrialNum <- 40
# from now on we continue analyzing this trial
testTrial <- subset(testData, trialN == badTrialNum)
# plot the data
ggplot(aes(frameN, thumbXraw), data = testTrial) + geom_point() # thumb data is bad
# how many bad frame are there?
max(testTrial$framesOccluded) # 15
# repair missing frames
testTrial$indexXrep <- with(testTrial, kin.signal.analysis(indexXraw, maxFrames= 20))
testTrial$indexYrep <- with(testTrial, kin.signal.analysis(indexYraw, maxFrames= 20))
testTrial$indexZrep <- with(testTrial, kin.signal.analysis(indexZraw, maxFrames= 20))
testTrial$thumbXrep <- with(testTrial, kin.signal.analysis(thumbXraw, maxFrames= 20))
testTrial$thumbYrep <- with(testTrial, kin.signal.analysis(thumbYraw, maxFrames= 20))
testTrial$thumbZrep <- with(testTrial, kin.signal.analysis(thumbZraw, maxFrames= 20))
# thumb data fixed
ggplot(aes(frameN, thumbXrep, color = fingersOccluded), data = testTrial) + geom_point()
##   1.1.2 filter ----
#    1.1.2.1 butterworth filter ----
# dual pass, 8–12 Hz cutoff, 2nd order
testTrial$indexXbw <- with(testTrial, kin.bwFilter(indexXrep, cutoff_freq = 10, type = "pass"))
testTrial$indexYbw <- with(testTrial, kin.bwFilter(indexYrep, cutoff_freq = 10, type = "pass"))
testTrial$indexZbw <- with(testTrial, kin.bwFilter(indexZrep, cutoff_freq = 10, type = "pass"))
testTrial$thumbXbw <- with(testTrial, kin.bwFilter(thumbXrep, cutoff_freq = 10, type = "pass"))
testTrial$thumbYbw <- with(testTrial, kin.bwFilter(thumbYrep, cutoff_freq = 10, type = "pass"))
testTrial$thumbZbw <- with(testTrial, kin.bwFilter(thumbZrep, cutoff_freq = 10, type = "pass"))
ggplot(data = testTrial) +
geom_point(aes(frameN, thumbXrep), color = "black") +
geom_point(aes(frameN, thumbXbw), color = "red", alpha=.5)
#    1.1.2.2 Savitzky-Golay filter ----
# 3rd order
testTrial$indexXsg <- with(testTrial, kin.sgFilter(indexXrep, ts = 1/85))
testTrial$indexYsg <- with(testTrial, kin.sgFilter(indexYrep, ts = 1/85))
testTrial$indexZsg <- with(testTrial, kin.sgFilter(indexZrep, ts = 1/85))
testTrial$thumbXsg <- with(testTrial, kin.sgFilter(thumbXrep, ts = 1/85))
testTrial$thumbYsg <- with(testTrial, kin.sgFilter(thumbYrep, ts = 1/85))
testTrial$thumbZsg <- with(testTrial, kin.sgFilter(thumbZrep, ts = 1/85))
ggplot(data = testTrial) +
geom_point(aes(frameN, thumbXrep), color = "black") +
geom_point(aes(frameN, thumbXsg), color = "green", alpha=.5)
#    1.2.2.3 choose filter and apply ----
# savitzky-golay filter is less invasive than butterworth (less variable residuals)
qplot(indexXbw-indexXrep, indexXsg-indexXrep, data=testTrial, geom="point") + coord_fixed()
qplot(thumbXbw-thumbXrep, thumbXsg-thumbXrep, data=testTrial, geom="point") + coord_fixed()
testTrial$indexX <- testTrial$indexXsg
testTrial$indexY <- testTrial$indexYsg
testTrial$indexZ <- testTrial$indexZsg
testTrial$thumbX <- testTrial$thumbXsg
testTrial$thumbY <- testTrial$thumbYsg
testTrial$thumbZ <- testTrial$thumbZsg
##   1.1.3 translate and rotate to have all trajectories going in the same direction ----
# the trajectory is assumed to start at origin (0,0,0)
# and terminate at a point (0,0,z)
# with x axis: rightwards positive, leftwards negative
#      y axis: upwards positive, downwards negative
#      z axis: forwards positive, backwards negative
# this requires a translation followed by a rotation
# starting dataset to apply translations and rotations on recursively
indData.backup <- testTrial[,c("indexX","indexY","indexZ")]
thuData.backup <- testTrial[,c("thumbX","thumbY","thumbZ")]
# dataset containing to-be-rotated fingers positions
rotData.backup <- rbind(indData.backup, setNames(thuData.backup, names(indData.backup)))
# define start and end of movement
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
# CASE 1: whole grasp
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
rotData <- rotData.backup - transData[rep(1, nrow(rotData.backup)),]
indData <- indData.backup - transData[rep(1, nrow(indData.backup)),]
thuData <- thuData.backup - transData[rep(1, nrow(thuData.backup)),]
# end coordinates of the whole grasp
end <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData <- kin.rotate.trajectory(indData, end)
thuData <- kin.rotate.trajectory(thuData, end)
# polish rotated dataset
indData <- as.data.frame(indData)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
ggplot() +
geom_point(aes(indexX, indexZ), data= rotData) +
geom_point(aes(indexX, indexZ), data= indData, color = "red") +
geom_point(aes(thumbX, thumbZ), data= thuData, color = "blue") +
coord_fixed()
# CASE 2: individual fingers
# --- INDEX
kmData <- cbind(indData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
indData <- indData.backup - transData[rep(1, nrow(indData.backup)),]
# end coordinates of the whole grasp
end.ind <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# --- THUMB
kmData <- cbind(thuData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
thuData <- thuData.backup - transData[rep(1, nrow(thuData.backup)),]
# end coordinates of the whole grasp
end.thu <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData.m <- kin.rotate.trajectory(indData, end.ind)
thuData.m <- kin.rotate.trajectory(thuData, end.thu)
# polish rotated dataset
indData <- as.data.frame(indData.m)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData.m)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
# merge rotated data and apply rotation
names(indData) <- paste(names(indData), "rot", sep="")
names(thuData) <- paste(names(thuData), "rot", sep="")
testTrial <- cbind(testTrial, indData, thuData)
testTrial$indexX <- testTrial$indexXrot
testTrial$indexY <- testTrial$indexYrot
testTrial$indexZ <- testTrial$indexZrot
testTrial$thumbX <- testTrial$thumbXrot
testTrial$thumbY <- testTrial$thumbYrot
testTrial$thumbZ <- testTrial$thumbZrot
##   1.1.4 find movement onset ----
#    1.1.4.1 calculate velocity vector ----
# using Savitzy-Golay filter (remember the frame rate!!)
testTrial$thumbXvel <- with(testTrial, kin.sgFilter(thumbX,m=1, ts = 1/85))
testTrial$thumbYvel <- with(testTrial, kin.sgFilter(thumbY,m=1, ts = 1/85))
testTrial$thumbZvel <- with(testTrial, kin.sgFilter(thumbZ,m=1, ts = 1/85))
testTrial$thumbVel <- with(testTrial, sqrt(thumbXvel^2 + thumbYvel^2 + thumbZvel^2)) # in mm/s
# using Savitzy-Golay filter (remember the frame rate!!)
testTrial$indexXvel <- with(testTrial, kin.sgFilter(indexX,m=1, ts = 1/85))
testTrial$indexYvel <- with(testTrial, kin.sgFilter(indexY,m=1, ts = 1/85))
testTrial$indexZvel <- with(testTrial, kin.sgFilter(indexZ,m=1, ts = 1/85))
testTrial$indexVel <- with(testTrial, sqrt(indexXvel^2 + indexYvel^2 + indexZvel^2)) # in mm/s
#    1.1.4.2 Savitzky-Golay filter velocitiy and acceleration vectors ----
# 3rd order
# filter velocity
testTrial$indexVel <- with(testTrial, kin.sgFilter(indexVel, ts = 1/85))
testTrial$thumbVel <- with(testTrial, kin.sgFilter(thumbVel, ts = 1/85))
# derive acceleration
testTrial$indexAcc <- with(testTrial, kin.sgFilter(indexVel, m=1, ts = 1/85))
testTrial$thumbAcc <- with(testTrial, kin.sgFilter(thumbVel, m=1, ts = 1/85))
# filter acceleration
testTrial$indexAcc <- with(testTrial, kin.sgFilter(indexAcc, p = 60, ts = 1/85))
testTrial$thumbAcc <- with(testTrial, kin.sgFilter(thumbAcc, p = 60, ts = 1/85))
ggplot(data = testTrial) +
geom_point(aes(time, thumbXvel), color = "red") +
geom_point(aes(time, thumbYvel), color = "darkgreen") +
geom_point(aes(time, thumbZvel), color = "blue") +
geom_point(aes(time, thumbVel), color = "black")
#    1.1.4.3 set onset frame ----
# set the onset frame to be the first of four consecutive vector velocity readings of greater than a threshold
# crop out the inbound portion of trajectory
testTrial.backup <- testTrial
return_threshold <- -100
testTrial <- subset(testTrial.backup, thumbZvel > return_threshold & indexZvel > return_threshold)
# crop out trajectory where z velocity is < threshold
# incrementally count frames where the condition is met
# when you have a string of coutns above say 5 take the fist frame as zero
onset_threshold <- 50
onsetFrame <- kin.find.onsetTime(testTrial$thumbVel, onset_threshold)
# time at movement onset
testTrial$time[testTrial$frameN == onsetFrame]
# center time at onset frame
testTrial$time <- testTrial$time - onsetTime
# crop out trajectory before onset
testTrial <- subset(testTrial, time >= 0)
# find core kinematics:
# velocity peak
# acceleration peak
# deceleration peak
ggplot(data = testTrial) +
geom_point(aes(time, thumbXvel), color = "red") +
geom_point(aes(time, thumbYvel), color = "darkgreen") +
geom_point(aes(time, thumbZvel), color = "blue") +
geom_point(aes(time, thumbVel), color = "black") +
geom_hline(yintercept = 50)
library(kinesis)
options(scipen = 1, digits = 3)
libraries()
library(cowplot)
# PROCEDURE FROM GALLIVAN and CHAPMAN 2014
#### Prepare the dataset ####
# keep only useful columns
usefCols <- c("trialN","indexXraw","indexYraw","indexZraw","thumbXraw","thumbYraw","thumbZraw")
# Fix dataset
testData <- data.check(rtgData_bad[usefCols])
# is there missing data for each digit in this dataset?
any(testData$fingersOccluded==1) # YES
#### 1. individual trial analysis ####
###  1.1 extract ROI ----
##   1.1.1 fill in missing frames ----
# inpaint_nans function in matlab
# select one trial with missing frames
# flag trials with missing frames
testData <- ddply(testData, .(trialN), mutate,
missing.frames = any(framesOccluded > 0))
# extract these trials number
trial.na.frame <- unique(subset(testData, missing.frames)$trialN)
# pick a random bad trial
badTrialNum <- 40
# from now on we continue analyzing this trial
testTrial <- subset(testData, trialN == badTrialNum)
# plot the data
ggplot(aes(frameN, thumbXraw), data = testTrial) + geom_point() # thumb data is bad
# how many bad frame are there?
max(testTrial$framesOccluded) # 15
# repair missing frames
testTrial$indexXrep <- with(testTrial, kin.signal.analysis(indexXraw, maxFrames= 20))
testTrial$indexYrep <- with(testTrial, kin.signal.analysis(indexYraw, maxFrames= 20))
testTrial$indexZrep <- with(testTrial, kin.signal.analysis(indexZraw, maxFrames= 20))
testTrial$thumbXrep <- with(testTrial, kin.signal.analysis(thumbXraw, maxFrames= 20))
testTrial$thumbYrep <- with(testTrial, kin.signal.analysis(thumbYraw, maxFrames= 20))
testTrial$thumbZrep <- with(testTrial, kin.signal.analysis(thumbZraw, maxFrames= 20))
# thumb data fixed
ggplot(aes(frameN, thumbXrep, color = fingersOccluded), data = testTrial) + geom_point()
##   1.1.2 filter ----
#    1.1.2.1 butterworth filter ----
# dual pass, 8–12 Hz cutoff, 2nd order
testTrial$indexXbw <- with(testTrial, kin.bwFilter(indexXrep, cutoff_freq = 10, type = "pass"))
testTrial$indexYbw <- with(testTrial, kin.bwFilter(indexYrep, cutoff_freq = 10, type = "pass"))
testTrial$indexZbw <- with(testTrial, kin.bwFilter(indexZrep, cutoff_freq = 10, type = "pass"))
testTrial$thumbXbw <- with(testTrial, kin.bwFilter(thumbXrep, cutoff_freq = 10, type = "pass"))
testTrial$thumbYbw <- with(testTrial, kin.bwFilter(thumbYrep, cutoff_freq = 10, type = "pass"))
testTrial$thumbZbw <- with(testTrial, kin.bwFilter(thumbZrep, cutoff_freq = 10, type = "pass"))
ggplot(data = testTrial) +
geom_point(aes(frameN, thumbXrep), color = "black") +
geom_point(aes(frameN, thumbXbw), color = "red", alpha=.5)
#    1.1.2.2 Savitzky-Golay filter ----
# 3rd order
testTrial$indexXsg <- with(testTrial, kin.sgFilter(indexXrep, ts = 1/85))
testTrial$indexYsg <- with(testTrial, kin.sgFilter(indexYrep, ts = 1/85))
testTrial$indexZsg <- with(testTrial, kin.sgFilter(indexZrep, ts = 1/85))
testTrial$thumbXsg <- with(testTrial, kin.sgFilter(thumbXrep, ts = 1/85))
testTrial$thumbYsg <- with(testTrial, kin.sgFilter(thumbYrep, ts = 1/85))
testTrial$thumbZsg <- with(testTrial, kin.sgFilter(thumbZrep, ts = 1/85))
ggplot(data = testTrial) +
geom_point(aes(frameN, thumbXrep), color = "black") +
geom_point(aes(frameN, thumbXsg), color = "green", alpha=.5)
#    1.2.2.3 choose filter and apply ----
# savitzky-golay filter is less invasive than butterworth (less variable residuals)
qplot(indexXbw-indexXrep, indexXsg-indexXrep, data=testTrial, geom="point") + coord_fixed()
qplot(thumbXbw-thumbXrep, thumbXsg-thumbXrep, data=testTrial, geom="point") + coord_fixed()
testTrial$indexX <- testTrial$indexXsg
testTrial$indexY <- testTrial$indexYsg
testTrial$indexZ <- testTrial$indexZsg
testTrial$thumbX <- testTrial$thumbXsg
testTrial$thumbY <- testTrial$thumbYsg
testTrial$thumbZ <- testTrial$thumbZsg
##   1.1.3 translate and rotate to have all trajectories going in the same direction ----
# the trajectory is assumed to start at origin (0,0,0)
# and terminate at a point (0,0,z)
# with x axis: rightwards positive, leftwards negative
#      y axis: upwards positive, downwards negative
#      z axis: forwards positive, backwards negative
# this requires a translation followed by a rotation
# starting dataset to apply translations and rotations on recursively
indData.backup <- testTrial[,c("indexX","indexY","indexZ")]
thuData.backup <- testTrial[,c("thumbX","thumbY","thumbZ")]
# dataset containing to-be-rotated fingers positions
rotData.backup <- rbind(indData.backup, setNames(thuData.backup, names(indData.backup)))
# define start and end of movement
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
# CASE 1: whole grasp
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
rotData <- rotData.backup - transData[rep(1, nrow(rotData.backup)),]
indData <- indData.backup - transData[rep(1, nrow(indData.backup)),]
thuData <- thuData.backup - transData[rep(1, nrow(thuData.backup)),]
# end coordinates of the whole grasp
end <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData <- kin.rotate.trajectory(indData, end)
thuData <- kin.rotate.trajectory(thuData, end)
# polish rotated dataset
indData <- as.data.frame(indData)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
ggplot() +
geom_point(aes(indexX, indexZ), data= rotData) +
geom_point(aes(indexX, indexZ), data= indData, color = "red") +
geom_point(aes(thumbX, thumbZ), data= thuData, color = "blue") +
coord_fixed()
# CASE 2: individual fingers
# --- INDEX
kmData <- cbind(indData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
indData <- indData.backup - transData[rep(1, nrow(indData.backup)),]
# end coordinates of the whole grasp
end.ind <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# --- THUMB
kmData <- cbind(thuData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
thuData <- thuData.backup - transData[rep(1, nrow(thuData.backup)),]
# end coordinates of the whole grasp
end.thu <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData.m <- kin.rotate.trajectory(indData, end.ind)
thuData.m <- kin.rotate.trajectory(thuData, end.thu)
# polish rotated dataset
indData <- as.data.frame(indData.m)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData.m)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
# merge rotated data and apply rotation
names(indData) <- paste(names(indData), "rot", sep="")
names(thuData) <- paste(names(thuData), "rot", sep="")
testTrial <- cbind(testTrial, indData, thuData)
testTrial$indexX <- testTrial$indexXrot
testTrial$indexY <- testTrial$indexYrot
testTrial$indexZ <- testTrial$indexZrot
testTrial$thumbX <- testTrial$thumbXrot
testTrial$thumbY <- testTrial$thumbYrot
testTrial$thumbZ <- testTrial$thumbZrot
##   1.1.4 find movement onset ----
#    1.1.4.1 calculate velocity vector ----
# using Savitzy-Golay filter (remember the frame rate!!)
testTrial$thumbXvel <- with(testTrial, kin.sgFilter(thumbX,m=1, ts = 1/85))
testTrial$thumbYvel <- with(testTrial, kin.sgFilter(thumbY,m=1, ts = 1/85))
testTrial$thumbZvel <- with(testTrial, kin.sgFilter(thumbZ,m=1, ts = 1/85))
testTrial$thumbVel <- with(testTrial, sqrt(thumbXvel^2 + thumbYvel^2 + thumbZvel^2)) # in mm/s
# using Savitzy-Golay filter (remember the frame rate!!)
testTrial$indexXvel <- with(testTrial, kin.sgFilter(indexX,m=1, ts = 1/85))
testTrial$indexYvel <- with(testTrial, kin.sgFilter(indexY,m=1, ts = 1/85))
testTrial$indexZvel <- with(testTrial, kin.sgFilter(indexZ,m=1, ts = 1/85))
testTrial$indexVel <- with(testTrial, sqrt(indexXvel^2 + indexYvel^2 + indexZvel^2)) # in mm/s
#    1.1.4.2 Savitzky-Golay filter velocitiy and acceleration vectors ----
# 3rd order
# filter velocity
testTrial$indexVel <- with(testTrial, kin.sgFilter(indexVel, ts = 1/85))
testTrial$thumbVel <- with(testTrial, kin.sgFilter(thumbVel, ts = 1/85))
# derive acceleration
testTrial$indexAcc <- with(testTrial, kin.sgFilter(indexVel, m=1, ts = 1/85))
testTrial$thumbAcc <- with(testTrial, kin.sgFilter(thumbVel, m=1, ts = 1/85))
# filter acceleration
testTrial$indexAcc <- with(testTrial, kin.sgFilter(indexAcc, p = 60, ts = 1/85))
testTrial$thumbAcc <- with(testTrial, kin.sgFilter(thumbAcc, p = 60, ts = 1/85))
ggplot(data = testTrial) +
geom_point(aes(time, thumbXvel), color = "red") +
geom_point(aes(time, thumbYvel), color = "darkgreen") +
geom_point(aes(time, thumbZvel), color = "blue") +
geom_point(aes(time, thumbVel), color = "black")
#    1.1.4.3 set onset frame ----
# set the onset frame to be the first of four consecutive vector velocity readings of greater than a threshold
# crop out the inbound portion of trajectory
testTrial.backup <- testTrial
return_threshold <- -100
testTrial <- subset(testTrial.backup, thumbZvel > return_threshold & indexZvel > return_threshold)
# crop out trajectory where z velocity is < threshold
# incrementally count frames where the condition is met
# when you have a string of coutns above say 5 take the fist frame as zero
onset_threshold <- 50
onsetFrame <- kin.find.onsetTime(testTrial$thumbVel, onset_threshold)
# time at movement onset
testTrial$time[testTrial$frameN == onsetFrame]
# center time at onset frame
testTrial$time <- testTrial$time - onsetTime
# crop out trajectory before onset
testTrial <- subset(testTrial, time >= 0)
# find core kinematics:
# velocity peak
# acceleration peak
# deceleration peak
ggplot(data = testTrial) +
geom_point(aes(time, thumbXvel), color = "red") +
geom_point(aes(time, thumbYvel), color = "darkgreen") +
geom_point(aes(time, thumbZvel), color = "blue") +
geom_point(aes(time, thumbVel), color = "black") +
geom_hline(yintercept = 50)
onsetTime <- testTrial$time[testTrial$frameN == onsetFrame]
testTrial$time <- testTrial$time - onsetTime
testTrial <- subset(testTrial, time >= 0)
ggplot(data = testTrial) +
geom_point(aes(time, thumbXvel), color = "red") +
geom_point(aes(time, thumbYvel), color = "darkgreen") +
geom_point(aes(time, thumbZvel), color = "blue") +
geom_point(aes(time, thumbVel), color = "black") +
geom_hline(yintercept = 50)
onset_threshold <- 100
onsetFrame <- kin.find.onsetTime(testTrial$thumbVel, onset_threshold)
onsetTime <- testTrial$time[testTrial$frameN == onsetFrame]
testTrial$time <- testTrial$time - onsetTime
testTrial <- subset(testTrial.backup, thumbZvel > return_threshold & indexZvel > return_threshold)
onset_threshold <- 100
onsetFrame <- kin.find.onsetTime(testTrial$thumbVel, onset_threshold)
onsetTime <- testTrial$time[testTrial$frameN == onsetFrame]
testTrial$time <- testTrial$time - onsetTime
testTrial <- subset(testTrial, time >= 0)
ggplot(data = testTrial) +
geom_point(aes(time, thumbXvel), color = "red") +
geom_point(aes(time, thumbYvel), color = "darkgreen") +
geom_point(aes(time, thumbZvel), color = "blue") +
geom_point(aes(time, thumbVel), color = "black") +
geom_hline(yintercept = 50)
testTrial <- subset(testTrial.backup, thumbZvel > return_threshold & indexZvel > return_threshold)
onset_threshold <- 100
onsetFrame <- kin.find.onsetTime(testTrial$thumbVel, onset_threshold)
testTrial$onsetTime <- testTrial$time[testTrial$frameN == onsetFrame]
testTrial <- subset(testTrial, frameN >= onsetFrame)
ggplot(data = testTrial) +
geom_point(aes(time, thumbXvel), color = "red") +
geom_point(aes(time, thumbYvel), color = "darkgreen") +
geom_point(aes(time, thumbZvel), color = "blue") +
geom_point(aes(time, thumbVel), color = "black") +
geom_hline(yintercept = 50)
