testTrial$time[testTrial$frameN == onsetFrame]
onsetTime <- testTrial$time[testTrial$frameN == onsetFrame]
ggplot(data = trialData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
trialData <- subset(trialData, frameN >= onsetFrame)
ggplot(data = trialData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
offsetFrame <- with(trialData, frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
trialData <- subset(trialData, frameN <= offsetFrame)
ggplot(data = trialData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
library(kinesis)
as.data.frame(end)
as.data.frame(t(end))
kin.rotate.trajectory(as.data.frame(t(end)), end)
kin.rotate.trajectory(as.data.frame(t(end-start)), end-start)
trialData$thuDist
round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
returnVel_threshold <- -100
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
ggplot(data = trialData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
ztheor
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
trialData <- subset(trialData, frameN <= offsetFrame)
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
ggplot(data = trialData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
graspData <- NULL
for(tN in unique(testData$trialN))
{
# trial
testTrial <- subset(testData, trialN == 50)
# signals analysis
start <- c(267,-332,-11.5)
end <- c(34.8,-53.4,-283)
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate, returnVel_threshold = return_threshold)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate, returnVel_threshold = return_threshold)
# merge back
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
# crop out the inbound portion of trajectory
returnVel_threshold <- -100
# crop return
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
# set offset time based on vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
graspData <- rbind(graspData, trialData)
}
graspData <- NULL
for(tN in unique(testData$trialN))
{
# trial
testTrial <- subset(testData, trialN == 50)
# signals analysis
start <- c(267,-332,-11.5)
end <- c(34.8,-53.4,-283)
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate)
# merge back
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
# crop out the inbound portion of trajectory
returnVel_threshold <- -100
# crop return
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
# set offset time based on vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
graspData <- rbind(graspData, trialData)
}
ggplot(data = graspData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
unique(graspData$trialN)
graspData <- NULL
for(tN in unique(testData$trialN))
{
# trial
testTrial <- subset(testData, trialN == tN)
# signals analysis
start <- c(267,-332,-11.5)
end <- c(34.8,-53.4,-283)
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate)
# merge back
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
# crop out the inbound portion of trajectory
returnVel_threshold <- -100
# crop return
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
# set offset time based on vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
graspData <- rbind(graspData, trialData)
}
ggplot(data = graspData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
unique(graspData$trialN)
ggplot(data = trialData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
tN
testTrial <- subset(testData, trialN == tN)
start <- c(267,-332,-11.5)
end <- c(34.8,-53.4,-283)
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate)
signal <- rtgData_bad[rtgData_bad$trialN==tN, c("thumbXraw","thumbYraw","thumbZraw")]
signal.name <- "thumb"
start <- c(267,-332,-11.5)
end <- c(34.8,-53.4,-283)
refreshRate <- 1/85
signal.backup <- signal
names(signal) <- paste(signal.name, c("X","Y","Z"), "raw", sep = "")
signalRep <- as.data.frame(apply(signal, 2, kin.signal.repair, maxFrames = maxFrames))
maxFrames = 20
signalRep <- as.data.frame(apply(signal, 2, kin.signal.repair, maxFrames = maxFrames))
names(signalRep) <- paste(signal.name, c("X","Y","Z"), "rep", sep = "")
signalSG <- as.data.frame(apply(signalRep, 2, kin.sgFilter, ts = deltaTime))
signal::sgolayfilt
trialData$thumbZ
signalRep
signalRep
kin.sgFilter(signalRep)
kin.sgFilter(signalRep[1])
kin.sgFilter(signalRep[,1])
signalRep[,1]
kin.sgFilter(na.omit(signalRep[,1]))
which(is.na(signalRep))
which(!is.na(signalRep))
output <- rep(NA, length(signalRep))
output[which(!is.na(signalRep))] <- kin.sgFilter(na.omit(signalRep[,1]))
output
qplot(signalRep[,1], output)
output
signalRep[,1]
output[which(!is.na(signalRep)),]
output <- rep(NA, length(signalRep))
output[which(!is.na(signalRep)),]
which(!is.na(signalRep))
output[which(!is.na(signalRep)),]
output[1,]
head(output)
output <- rep(NA, length(signalRep))
output[which(!is.na(signalRep))] <- kin.sgFilter(na.omit(signalRep[,1]))
head(output)
qplot(signalRep[,1], output)
output <- rep(NA, length(signalRep))
output[which(!is.na(signalRep[,1]))] <- kin.sgFilter(na.omit(signalRep[,1]))
qplot(signalRep[,1], output)
output[which(!is.na(signalRep[,1]))] <- kin.sgFilter(na.omit(signalRep[,1]), p = 10)
length(signalRep)
qplot(signalRep[,1], output)
signal::sgolayfilt
library(kinesis)
signalRep <- as.data.frame(apply(signal, 2, kin.signal.repair, maxFrames = maxFrames))
maxFrames = 20
signal <- rtgData_bad[rtgData_bad$trialN==50, c("thumbXraw","thumbYraw","thumbZraw")]
start <- c(267,-332,-11.5)
end <- c(34.8,-53.4,-283)
refreshRate <- 1/85
signal.backup <- signal
names(signal) <- paste(signal.name, c("X","Y","Z"), "raw", sep = "")
signalRep <- as.data.frame(apply(signal, 2, kin.signal.repair, maxFrames = maxFrames))
names(signalRep) <- paste(signal.name, c("X","Y","Z"), "rep", sep = "")
signalSG <- as.data.frame(apply(signalRep, 2, kin.sgFilter, ts = deltaTime))
names(signalSG) <- paste(signal.name, c("X","Y","Z"), "sg", sep = "")
M <- matrix(rep(start, nrow(signalSG)), ncol = 3, byrow = T) # replicate origin to create a dataset to subtract to the signal
signalTra <- as.data.frame(signalSG - M) # translate
names(signalTra) <- paste(signal.name, c("X","Y","Z"), "tra", sep = "")
signalRot <- as.data.frame(kin.rotate.trajectory(signalTra, end - start))
names(signalRot) <- paste(signal.name, c("X","Y","Z"), "rot", sep = "")
signalVel <- as.data.frame(apply(signalRot, 2, kin.sgFilter, m=1, ts = deltaTime)) # 3D velocities
names(signalVel) <- paste(signal.name, c("X","Y","Z"), "vel", sep = "")
signalSG <- as.data.frame(apply(signalRep, 2, kin.sgFilter, ts = deltaTime))
deltaTime
rm(list = ls())
usefCols <- c("trialN","indexXraw","indexYraw","indexZraw","thumbXraw","thumbYraw","thumbZraw")
testData <- data.check.test(rtgData_bad[usefCols])
test
data.check.test <- function(dataset, refreshRate = 85, time.unit = 1, ...)
{
# cat("Please input the name of the column coding for the trials:")
# trialCol <- readline()
#
# cat("Number of signals present in the dataset:")
# n_sgn <- as.numeric(as.character(readline()))
#
# sgnCols <- NULL
# for(sgn in 1:n_sgn)
# {
#   names_sgn_temp <- NULL
#   for(coord in c("x","y","z")){
#     cat("Name of column coding for ",coord," coord of signal #", sgn, ": ", sep="")
#     names_sgn_temp <- c(names_sgn_temp, readline())
#   }
#   sgnCols[[sgn]] <- names_sgn_temp
#   rm(names_sgn_temp)
# }
#
# # cleanup
# rm(sgn)
# rm(coord)
#
# reqCols <- c("subjName", "frameN", "frameT", "time", "signalOccluded")
# reqCols_check <- NULL
# for(rCol in reqCols)
# {
#   cat("Is ",rCol," column present? YES: type its name / NO: type 0 (zero):", sep="")
#   reqCols_check <- c(reqCols_check, readline())
# }
#
# # create working dataset
# wdataset <- dataset[names(dataset)%in%c(trialCol, unlist(sgnCols))]
# assign refreshRate & time.unit to global environment for looping inside ddply (temporary)
assign("refreshRate", refreshRate, envir = .GlobalEnv)
assign("time.unit", time.unit, envir = .GlobalEnv)
reqCols <- c("subjName","frameN", "time","deltaTime")
missingCols <- reqCols[!reqCols %in% names(dataset)]
if (length(missingCols) > 0) {
cat("The following columns do not exist:\n")
cat(missingCols, sep = ", ")
cat("\n\nFixing...\n\n")
# Fix subjName
if ("subjName" %in% missingCols) {
cat("Please type subject name:\n")
dataset$subjName <- readline()
cat("subjName added.\n")
}
# Fix frameN
if ("frameN" %in% missingCols) {
dataset <- kin.frameN(dataset)
cat("frameN added.\n")
}
# Fix frameT
if ("deltaTime" %in% missingCols) {
# if time does not exists, create deltaTime
if("time" %in% missingCols){
dataset <- ddply(dataset, .(trialN), mutate,
frameT = time.unit / refreshRate)
} else {
# else deltaTime is delta time
dataset <- ddply(dataset, .(trialN), mutate,
frameT = c(NA, diff(time)))
}
cat("deltaTime added.\n")
}
# Fix time
if ("time" %in% missingCols) {
dataset <- kin.time(dataset, refreshRate, time.unit)
cat("time added.\n")
}
cat("\nDatabase fixed successfully.")
}
else {
cat("\nDatabase looks good.")
}
# remove refreshRate & time.unit from global environment
remove(refreshRate, envir = .GlobalEnv)
remove(time.unit, envir = .GlobalEnv)
return(dataset)
}
usefCols <- c("trialN","indexXraw","indexYraw","indexZraw","thumbXraw","thumbYraw","thumbZraw")
testData <- data.check.test(rtgData_bad[usefCols])
graspData <- NULL
for(tN in unique(testData$trialN))
{
# trial
testTrial <- subset(testData, trialN == tN)
# signals analysis
start <- c(267,-332,-11.5)
end <- c(34.8,-53.4,-283)
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate)
# merge back
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
# crop out the inbound portion of trajectory
returnVel_threshold <- -100
# crop return
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
# set offset time based on vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
graspData <- rbind(graspData, trialData)
}
devtools::document()
library(kinesis)
graspData <- NULL
for(tN in unique(testData$trialN))
{
# trial
testTrial <- subset(testData, trialN == tN)
# signals analysis
start <- c(267,-332,-11.5)
end <- c(34.8,-53.4,-283)
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate)
# merge back
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
# crop out the inbound portion of trajectory
returnVel_threshold <- -100
# crop return
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
# set offset time based on vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
graspData <- rbind(graspData, trialData)
}
ggplot(data = graspData) +
geom_point(aes(thuDist, indexZ), color = "red") +
geom_point(aes(thuDist, thumbZ), color = "blue") +
coord_fixed()
ggplot(data = subset(graspData, trialN==46)) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
