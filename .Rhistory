trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
graspData <- rbind(graspData, trialData)
}
devtools::document()
library(kinesis)
graspData <- NULL
for(tN in unique(testData$trialN))
{
# trial
testTrial <- subset(testData, trialN == tN)
# signals analysis
start <- c(267,-332,-11.5)
end <- c(34.8,-53.4,-283)
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate)
# merge back
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
# crop out the inbound portion of trajectory
returnVel_threshold <- -100
# crop return
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
# set offset time based on vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
graspData <- rbind(graspData, trialData)
}
ggplot(data = graspData) +
geom_point(aes(thuDist, indexZ), color = "red") +
geom_point(aes(thuDist, thumbZ), color = "blue") +
coord_fixed()
ggplot(data = subset(graspData, trialN==46)) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
library(kinesis)
options(scipen = 1, digits = 3)
libraries()
library(cowplot)
# PROCEDURE FROM GALLIVAN and CHAPMAN 2014
#### Prepare the dataset ####
# keep only useful columns
usefCols <- c("trialN","indexXraw","indexYraw","indexZraw","thumbXraw","thumbYraw","thumbZraw")
# check dataset
testData <- data.check.test(rtgData_bad[usefCols])
test
graspData <- NULL
for(tN in unique(testData$trialN))
{
cat("---- trial #", tN, ". ----\n\n")
# trial
testTrial <- subset(testData, trialN == tN)
# signals analysis
start <- c(267,-332,-11.5)
end <- c(34.8,-53.4,-283)
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate)
# merge back
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
# crop out the inbound portion of trajectory
returnVel_threshold <- -100
# crop return
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
# set offset time based on vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
graspData <- rbind(graspData, trialData)
}
data.check.test <- function(dataset, refreshRate = 85, time.unit = 1, ...)
{
# cat("Please input the name of the column coding for the trials:")
# trialCol <- readline()
#
# cat("Number of signals present in the dataset:")
# n_sgn <- as.numeric(as.character(readline()))
#
# sgnCols <- NULL
# for(sgn in 1:n_sgn)
# {
#   names_sgn_temp <- NULL
#   for(coord in c("x","y","z")){
#     cat("Name of column coding for ",coord," coord of signal #", sgn, ": ", sep="")
#     names_sgn_temp <- c(names_sgn_temp, readline())
#   }
#   sgnCols[[sgn]] <- names_sgn_temp
#   rm(names_sgn_temp)
# }
#
# # cleanup
# rm(sgn)
# rm(coord)
#
# reqCols <- c("subjName", "frameN", "frameT", "time", "signalOccluded")
# reqCols_check <- NULL
# for(rCol in reqCols)
# {
#   cat("Is ",rCol," column present? YES: type its name / NO: type 0 (zero):", sep="")
#   reqCols_check <- c(reqCols_check, readline())
# }
#
# # create working dataset
# wdataset <- dataset[names(dataset)%in%c(trialCol, unlist(sgnCols))]
# assign refreshRate & time.unit to global environment for looping inside ddply (temporary)
assign("refreshRate", refreshRate, envir = .GlobalEnv)
assign("time.unit", time.unit, envir = .GlobalEnv)
reqCols <- c("subjName","frameN", "time","deltaTime")
missingCols <- reqCols[!reqCols %in% names(dataset)]
if (length(missingCols) > 0) {
cat("The following columns do not exist:\n")
cat(missingCols, sep = ", ")
cat("\n\nFixing...\n\n")
# Fix subjName
if ("subjName" %in% missingCols) {
cat("Please type subject name:\n")
dataset$subjName <- readline()
cat("subjName added.\n")
}
# Fix frameN
if ("frameN" %in% missingCols) {
dataset <- kin.frameN(dataset)
cat("frameN added.\n")
}
# Fix frameT
if ("deltaTime" %in% missingCols) {
# if time does not exists, create deltaTime
if("time" %in% missingCols){
dataset <- ddply(dataset, .(trialN), mutate,
frameT = time.unit / refreshRate)
} else {
# else deltaTime is delta time
dataset <- ddply(dataset, .(trialN), mutate,
frameT = c(NA, diff(time)))
}
cat("deltaTime added.\n")
}
# Fix time
if ("time" %in% missingCols) {
dataset <- kin.time(dataset, refreshRate, time.unit)
cat("time added.\n")
}
cat("\nDatabase fixed successfully.")
}
else {
cat("\nDatabase looks good.")
}
# remove refreshRate & time.unit from global environment
remove(refreshRate, envir = .GlobalEnv)
remove(time.unit, envir = .GlobalEnv)
return(dataset)
}
options(scipen = 1, digits = 3)
libraries()
library(cowplot)
# PROCEDURE FROM GALLIVAN and CHAPMAN 2014
#### Prepare the dataset ####
# keep only useful columns
usefCols <- c("trialN","indexXraw","indexYraw","indexZraw","thumbXraw","thumbYraw","thumbZraw")
# check dataset
testData <- data.check.test(rtgData_bad[usefCols])
graspData <- NULL
for(tN in unique(testData$trialN))
{
cat("---- trial #", tN, ". ----\n\n")
# trial
testTrial <- subset(testData, trialN == tN)
# signals analysis
start <- c(267,-332,-11.5)
end <- c(34.8,-53.4,-283)
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate)
# merge back
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
# crop out the inbound portion of trajectory
returnVel_threshold <- -100
# crop return
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
# set offset time based on vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
graspData <- rbind(graspData, trialData)
}
ggplot(data = subset(graspData, trialN==46)) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
ggplot(data = subset(graspData, trialN==58)) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
head(testTrial)
kmData <- testTrial[c("indexXraw","indexYraw","indexZraw","thumbXraw","thumbYraw","thumbZraw","time")]
km.res <- as.data.frame(kmeans(testTrial, 2)$centers)
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res
kmData <- testTrial[c("thumbXraw","thumbYraw","thumbZraw","time")]
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
km.res
km.res[km.res$moment=="end",1:3]
tN
testTrial <- subset(testData, trialN == 58)
kmData <- testTrial[c("thumbXraw","thumbYraw","thumbZraw","time")]
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
end <- km.res[km.res$moment=="end",1:3]
end
graspData <- NULL
for(tN in unique(testData$trialN))
{
cat("---- trial #", tN, ". ----\n\n")
# trial
testTrial <- subset(testData, trialN == tN)
# signals analysis
start <- c(267,-332,-11.5)
kmData <- testTrial[c("thumbXraw","thumbYraw","thumbZraw","time")]
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
end <- km.res[km.res$moment=="end",1:3]
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate)
# merge back
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
# crop out the inbound portion of trajectory
returnVel_threshold <- -100
# crop return
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
# set offset time based on vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
graspData <- rbind(graspData, trialData)
}
end
end <- as.numeric(km.res[km.res$moment=="end",1:3])
end
graspData <- NULL
for(tN in unique(testData$trialN))
{
cat("---- trial #", tN, ". ----\n\n")
# trial
testTrial <- subset(testData, trialN == tN)
# signals analysis
start <- c(267,-332,-11.5)
kmData <- testTrial[c("thumbXraw","thumbYraw","thumbZraw","time")]
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
end <- as.numeric(km.res[km.res$moment=="end",1:3])
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate)
# merge back
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
# crop out the inbound portion of trajectory
returnVel_threshold <- -100
# crop return
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
# set offset time based on vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
graspData <- rbind(graspData, trialData)
}
ggplot(data = subset(graspData, trialN==58)) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
ggplot(data = graspData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
coord_fixed()
end
end[3]
graspData <- NULL
for(tN in unique(testData$trialN))
{
cat("---- trial #", tN, ". ----\n\n")
# trial
testTrial <- subset(testData, trialN == tN)
# signals analysis
start <- c(267,-332,-11.5)
kmData <- testTrial[c("thumbXraw","thumbYraw","thumbZraw","time")]
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
end <- as.numeric(km.res[km.res$moment=="end",1:3])
refreshRate <- 1/85
return_threshold <- -100
index.signal <- testTrial[,c("indexXraw","indexYraw","indexZraw")]
thumb.signal <- testTrial[,c("thumbXraw","thumbYraw","thumbZraw")]
indexData <- kin.signal.analysis(index.signal, "index", start, end, deltaTime = refreshRate)
thumbData <- kin.signal.analysis(thumb.signal, "thumb", start, end, deltaTime = refreshRate)
# merge back
trialData <- cbind(testTrial[c("subjName","trialN","frameN","frameT","time")], indexData, thumbData)
# crop out the inbound portion of trajectory
returnVel_threshold <- -100
# crop return
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
# set onset time
onsetVel_threshold <- 100
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop out trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
# set offset time based on vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# find offest time
# theoretical z distance
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2), frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop out trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
# space normalization
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin that distance
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
trialData$objectZ <- ifelse(end[3] > -300, 270, 350)
graspData <- rbind(graspData, trialData)
}
ggplot(data = graspData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
facet_grid(. ~ objectZ) +
coord_fixed()
ggplot(data = graspData) +
geom_point(aes(thuDist, indexZ), color = "red") +
geom_point(aes(thuDist, thumbZ), color = "blue") +
facet_grid(. ~ objectZ)
ggplot(data = graspData) +
geom_point(aes(-thuDist, indexZ), color = "red") +
geom_point(aes(-thuDist, thumbZ), color = "blue") +
facet_grid(. ~ objectZ)
ggplot(data = graspData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
facet_grid(. ~ objectZ) +
coord_fixed()
setwd("P:/### LABS ###/Domini-ShapeLab/carlo/2012-2013/dataExpOct")
setwd("P:/### LABS ###/Domini-ShapeLab/carlo/2012-2013/dataExpOct/")
Data <- read.table("gData.txt", header=TRUE)
head(Data)
unique(Data$subjN)
