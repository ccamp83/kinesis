{
# form the couples relative to each projection plane
# frontoparallel plane (x,y) | trasversal plane (x,z) | sagittal plane (z,y)
endCoord.x <- c(end[1], end[3], end[3])
endCoord.y <- c(end[2], end[1], end[2])
# compute angles
theta <- atan2(endCoord.y, endCoord.x)
# transform to 360 deg
theta[which(theta < 0)] <- theta[which(theta < 0)] + pi
# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
return(data)
}
# CASE 1: whole grasp
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
rotData <- rotData.backup - transData[rep(1, nrow(rotData.backup)),]
indData <- indData.backup - transData[rep(1, nrow(indData)),]
thuData <- thuData.backup - transData[rep(1, nrow(thuData)),]
# end coordinates of the whole grasp
end <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData <- kin.rotate.trajectory(indData, end)
thuData <- kin.rotate.trajectory(thuData, end)
# polish rotated dataset
indData <- as.data.frame(indData)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
testTrial$indexY <- testTrial$indexY * -1
testTrial$thumbY <- testTrial$thumbY * -1
indData.backup <- testTrial[,c("indexX","indexY","indexZ")]
thuData.backup <- testTrial[,c("thumbX","thumbY","thumbZ")]
# dataset containing to-be-rotated fingers positions
rotData.backup <- rbind(as.matrix(indData.backup),as.matrix(thuData.backup))
# define start and end of movement
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
# CASE 1: whole grasp
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
rotData <- rotData.backup - transData[rep(1, nrow(rotData.backup)),]
indData <- indData.backup - transData[rep(1, nrow(indData)),]
thuData <- thuData.backup - transData[rep(1, nrow(thuData)),]
# end coordinates of the whole grasp
end <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData <- kin.rotate.trajectory(indData, end)
thuData <- kin.rotate.trajectory(thuData, end)
# polish rotated dataset
indData <- as.data.frame(indData)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
# CASE 2: individual fingers
# --- INDEX
kmData <- cbind(indData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
indData <- indData.backup - transData[rep(1, nrow(indData.backup)),]
# end coordinates of the whole grasp
end.ind <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# --- THUMB
kmData <- cbind(thuData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
thuData <- thuData.backup - transData[rep(1, nrow(thuData.backup)),]
# end coordinates of the whole grasp
end.thu <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData.m <- kin.rotate.trajectory(indData, end.ind)
thuData.m <- kin.rotate.trajectory(thuData, end.thu)
# polish rotated dataset
indData <- as.data.frame(indData.m)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData.m)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
end.thu
transData
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
transData
plot3d(rotData[c(1,3,2)])
testTrial$indexX <- testTrial$indexXsg
testTrial$indexY <- testTrial$indexYsg
testTrial$indexZ <- testTrial$indexZsg
testTrial$thumbX <- testTrial$thumbXsg
testTrial$thumbY <- testTrial$thumbYsg
testTrial$thumbZ <- testTrial$thumbZsg
indData.backup <- testTrial[,c("indexX","indexY","indexZ")]
thuData.backup <- testTrial[,c("thumbX","thumbY","thumbZ")]
rotData.backup <- rbind(as.matrix(indData.backup),as.matrix(thuData.backup))
plot3d(rotData[c(1,3,2)])
plot3d(rotData.backup[c(1,3,2)])
rotData.backup
plot3d(rotData.backup[,c(1,3,2)])
plot3d(rotData[c(1,3,2)])
plot3d(rotData[,c(1,3,2)])
is.data.frame(rotData.backup)
rotData.backup <- as.data.frame(rbind(as.matrix(indData.backup),as.matrix(thuData.backup)))
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
rotData <- rotData.backup - transData[rep(1, nrow(rotData.backup)),]
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
rotData.backup
rotData.backup <- as.data.frame(rbind(as.matrix(indData.backup),as.matrix(thuData.backup)))
rotData.backup
rbind(as.matrix(indData.backup),as.matrix(thuData.backup))
as.data.frame(rbind(as.matrix(indData.backup),as.matrix(thuData.backup)))
is.data.frame(rbind(as.matrix(indData.backup),as.matrix(thuData.backup)))
data.frame(rbind(as.matrix(indData.backup),as.matrix(thuData.backup)))
?rbind
rotData.backup <- rbind(indData.backup,thuData.backup, deparse.level = 0)
rotData.backup <- rbind.fill(indData.backup,thuData.backup)
plot3d(rotData.backup[c(1,3,2)])
testTrial$indexX <- testTrial$indexXsg
testTrial$indexY <- testTrial$indexYsg
testTrial$indexZ <- testTrial$indexZsg
testTrial$thumbX <- testTrial$thumbXsg
testTrial$thumbY <- testTrial$thumbYsg
testTrial$thumbZ <- testTrial$thumbZsg
indData.backup <- testTrial[,c("indexX","indexY","indexZ")]
thuData.backup <- testTrial[,c("thumbX","thumbY","thumbZ")]
rotData.backup <- rbind.fill(indData.backup,thuData.backup)
plot3d(rotData.backup[c(1,3,2)])
testTrial$thumbY <- testTrial$thumbY * -1
testTrial$thumbZ <- testTrial$thumbZ * -1
indData.backup <- testTrial[,c("indexX","indexY","indexZ")]
thuData.backup <- testTrial[,c("thumbX","thumbY","thumbZ")]
rotData.backup <- rbind.fill(indData.backup,thuData.backup)
plot3d(rotData.backup[c(1,3,2)])
plot3d(rotData.backup[c(1,3,2)])
testTrial$indexX <- testTrial$indexXsg
testTrial$indexY <- testTrial$indexYsg
testTrial$indexZ <- testTrial$indexZsg
testTrial$thumbX <- testTrial$thumbXsg
testTrial$thumbY <- testTrial$thumbYsg
testTrial$thumbZ <- testTrial$thumbZsg
##   1.1.3 translate and rotate to have all trajectories going in the same direction ----
# the trajectory is assumed to start at origin (0,0,0)
# and terminate at a point (0,0,z)
# with x axis: rightwards positive, leftwards negative
#      y axis: upwards positive, downwards negative
#      z axis: forwards positive, backwards negative
# this requires a translation followed by a rotation
# we know that in this dataset the z axis is reversed relative to the expected direction
# so we flip it
testTrial$indexZ <- testTrial$indexZ * -1
testTrial$thumbZ <- testTrial$thumbZ * -1
# starting dataset to apply translations and rotations on recursively
indData.backup <- testTrial[,c("indexX","indexY","indexZ")]
thuData.backup <- testTrial[,c("thumbX","thumbY","thumbZ")]
# dataset containing to-be-rotated fingers positions
rotData.backup <- rbind.fill(indData.backup,thuData.backup)
plot3d(rotData.backup[c(1,3,2)])
nrow(rotData.backup)
testTrial$indexX <- testTrial$indexXsg
testTrial$indexY <- testTrial$indexYsg
testTrial$indexZ <- testTrial$indexZsg
testTrial$thumbX <- testTrial$thumbXsg
testTrial$thumbY <- testTrial$thumbYsg
testTrial$thumbZ <- testTrial$thumbZsg
##   1.1.3 translate and rotate to have all trajectories going in the same direction ----
# the trajectory is assumed to start at origin (0,0,0)
# and terminate at a point (0,0,z)
# with x axis: rightwards positive, leftwards negative
#      y axis: upwards positive, downwards negative
#      z axis: forwards positive, backwards negative
# this requires a translation followed by a rotation
# we know that in this dataset the z axis is reversed relative to the expected direction
# so we flip it
testTrial$indexZ <- testTrial$indexZ * -1
testTrial$thumbZ <- testTrial$thumbZ * -1
# starting dataset to apply translations and rotations on recursively
indData.backup <- testTrial[,c("indexX","indexY","indexZ")]
thuData.backup <- testTrial[,c("thumbX","thumbY","thumbZ")]
# dataset containing to-be-rotated fingers positions
rotData.backup <- rbind.fill(indData.backup,thuData.backup)
plot3d(rotData.backup[c(1,3,2)])
plot3d(rotData.backup[,c(1,3,2)])
# CASE 1: whole grasp
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
rotData <- rotData.backup - transData[rep(1, nrow(rotData.backup)),]
indData <- indData.backup - transData[rep(1, nrow(indData)),]
thuData <- thuData.backup - transData[rep(1, nrow(thuData)),]
# end coordinates of the whole grasp
end <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData <- kin.rotate.trajectory(indData, end)
thuData <- kin.rotate.trajectory(thuData, end)
# polish rotated dataset
indData <- as.data.frame(indData)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
rotData <- rotData.backup - transData[rep(1, nrow(rotData.backup)),]
indData <- indData.backup - transData[rep(1, nrow(indData)),]
transData[rep(1, nrow(rotData.backup)),]
rotData.backup
thuData.backup
testTrial$indexX <- testTrial$indexXsg
testTrial$indexY <- testTrial$indexYsg
testTrial$indexZ <- testTrial$indexZsg
testTrial$thumbX <- testTrial$thumbXsg
testTrial$thumbY <- testTrial$thumbYsg
testTrial$thumbZ <- testTrial$thumbZsg
##   1.1.3 translate and rotate to have all trajectories going in the same direction ----
# the trajectory is assumed to start at origin (0,0,0)
# and terminate at a point (0,0,z)
# with x axis: rightwards positive, leftwards negative
#      y axis: upwards positive, downwards negative
#      z axis: forwards positive, backwards negative
# this requires a translation followed by a rotation
# we know that in this dataset the z axis is reversed relative to the expected direction
# so we flip it
testTrial$indexZ <- testTrial$indexZ * -1
testTrial$thumbZ <- testTrial$thumbZ * -1
# starting dataset to apply translations and rotations on recursively
indData.backup <- testTrial[,c("indexX","indexY","indexZ")]
thuData.backup <- testTrial[,c("thumbX","thumbY","thumbZ")]
# dataset containing to-be-rotated fingers positions
rotData.backup <- rbind(indData.backup,setNames(thuData.backup, indData.backup))
setNames(thuData.backup, indData.backup)
?setNames
rotData.backup <- rbind(indData.backup, setNames(thuData.backup, names(indData.backup)))
plot3d(rotData.backup[,c(1,3,2)])
testTrial$indexX <- testTrial$indexXsg
testTrial$indexY <- testTrial$indexYsg
testTrial$indexZ <- testTrial$indexZsg
testTrial$thumbX <- testTrial$thumbXsg
testTrial$thumbY <- testTrial$thumbYsg
testTrial$thumbZ <- testTrial$thumbZsg
##   1.1.3 translate and rotate to have all trajectories going in the same direction ----
# the trajectory is assumed to start at origin (0,0,0)
# and terminate at a point (0,0,z)
# with x axis: rightwards positive, leftwards negative
#      y axis: upwards positive, downwards negative
#      z axis: forwards positive, backwards negative
# this requires a translation followed by a rotation
# we know that in this dataset the z axis is reversed relative to the expected direction
# so we flip it
testTrial$indexZ <- testTrial$indexZ * -1
testTrial$thumbZ <- testTrial$thumbZ * -1
# starting dataset to apply translations and rotations on recursively
indData.backup <- testTrial[,c("indexX","indexY","indexZ")]
thuData.backup <- testTrial[,c("thumbX","thumbY","thumbZ")]
# dataset containing to-be-rotated fingers positions
rotData.backup <- rbind(indData.backup, setNames(thuData.backup, names(indData.backup)))
# CASE 1: whole grasp
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
rotData <- rotData.backup - transData[rep(1, nrow(rotData.backup)),]
indData <- indData.backup - transData[rep(1, nrow(indData)),]
thuData <- thuData.backup - transData[rep(1, nrow(thuData)),]
# end coordinates of the whole grasp
end <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData <- kin.rotate.trajectory(indData, end)
thuData <- kin.rotate.trajectory(thuData, end)
# polish rotated dataset
indData <- as.data.frame(indData)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
# CASE 2: individual fingers
# --- INDEX
kmData <- cbind(indData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
indData <- indData.backup - transData[rep(1, nrow(indData.backup)),]
# end coordinates of the whole grasp
end.ind <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# --- THUMB
kmData <- cbind(thuData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
thuData <- thuData.backup - transData[rep(1, nrow(thuData.backup)),]
# end coordinates of the whole grasp
end.thu <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData.m <- kin.rotate.trajectory(indData, end.ind)
thuData.m <- kin.rotate.trajectory(thuData, end.thu)
# polish rotated dataset
indData <- as.data.frame(indData.m)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData.m)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
end.ind
end.thu
indData.m <- kin.rotate.trajectory(indData, end.thu)
# --- INDEX
kmData <- cbind(indData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
indData <- indData.backup - transData[rep(1, nrow(indData.backup)),]
# end coordinates of the whole grasp
end.ind <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# --- THUMB
kmData <- cbind(thuData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
thuData <- thuData.backup - transData[rep(1, nrow(thuData.backup)),]
# end coordinates of the whole grasp
end.thu <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData.m <- kin.rotate.trajectory(indData, end.thu)
thuData.m <- kin.rotate.trajectory(thuData, end.thu)
indData <- as.data.frame(indData.m)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData.m)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
end.ind
end.thu
kin.rotate.trajectory <- function(data, end)
{
# if data is not a matrix, convert to matrix
if(!is.matrix(data))
{
data = as.matrix(data)
}
# three-steps rotation in 3D
for(plane in c("f","t","s"))
{
# form the couples relative to each projection plane
# frontoparallel plane (x,y) | trasversal plane (x,z) | sagittal plane (z,y)
endCoord.x <- c(end[1], end[3], end[3])
endCoord.y <- c(end[2], end[1], end[2])
# compute angles
theta <- atan(endCoord.y/endCoord.x)
# transform to 360 deg
# theta[which(theta < 0)] <- theta[which(theta < 0)] + pi
# rotate the trajectory
data <- switch(plane,
f = rotate3d(data, theta[1], 0, 0, 1),
t = rotate3d(data, theta[2], 0, 1, 0),
s = rotate3d(data, theta[3], 1, 0, 0)
)
# rotate end coordinates
end <- switch(plane,
f = rotate3d(end, theta[1], 0, 0, 1),
t = rotate3d(end, theta[2], 0, 1, 0),
s = rotate3d(end, theta[3], 1, 0, 0)
)
}
return(data)
}
# --- INDEX
kmData <- cbind(indData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
indData <- indData.backup - transData[rep(1, nrow(indData.backup)),]
# end coordinates of the whole grasp
end.ind <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# --- THUMB
kmData <- cbind(thuData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
thuData <- thuData.backup - transData[rep(1, nrow(thuData.backup)),]
# end coordinates of the whole grasp
end.thu <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData.m <- kin.rotate.trajectory(indData, end.ind)
thuData.m <- kin.rotate.trajectory(thuData, end.thu)
# polish rotated dataset
indData <- as.data.frame(indData.m)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData.m)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
# CASE 1: whole grasp
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
rotData <- rotData.backup - transData[rep(1, nrow(rotData.backup)),]
indData <- indData.backup - transData[rep(1, nrow(indData)),]
thuData <- thuData.backup - transData[rep(1, nrow(thuData)),]
# end coordinates of the whole grasp
end <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData <- kin.rotate.trajectory(indData, end)
thuData <- kin.rotate.trajectory(thuData, end)
# polish rotated dataset
indData <- as.data.frame(indData)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
# CASE 2: individual fingers
# --- INDEX
kmData <- cbind(indData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
indData <- indData.backup - transData[rep(1, nrow(indData.backup)),]
# end coordinates of the whole grasp
end.ind <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# --- THUMB
kmData <- cbind(thuData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
thuData <- thuData.backup - transData[rep(1, nrow(thuData.backup)),]
# end coordinates of the whole grasp
end.thu <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData.m <- kin.rotate.trajectory(indData, end.ind)
thuData.m <- kin.rotate.trajectory(thuData, end.thu)
# polish rotated dataset
indData <- as.data.frame(indData.m)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData.m)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
library(kinesis)
