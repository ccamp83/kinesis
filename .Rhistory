# of each position of each finger
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15)
# frontoparallel plane (x,y)
theta.f = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexY[moment=="end"]-indexY[moment=="start"])))
# trasversal plane (x,z)
theta.t = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
# sagittal plane (y,z)
theta.s = with(km.res, atan2((indexY[moment=="end"]-indexY[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
theta.s*180/pi
# first we center the trajectory at start
# by translating by the centroids returned by the cluster analysis
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
transData <- transData[rep(1, nrow(rotData)),] # repeat for matrix substraction
rotData <- rotData.backup - transData # matrix subtraction
points3d(rotData)
cols <- data.frame(p = c("f","t","s"), color = c("red","blue","green"))
# this requires a three-steps rotation in 3D
for(plane in c("t","s"))
{
rotData <- switch(plane,
f = rotate3d(as.matrix(rotData), theta.f, 0, 0, 1),
t = rotate3d(as.matrix(rotData), theta.t, 0, 1, 0),
s = rotate3d(as.matrix(rotData), theta.s, 1, 0, 0)
)
rotData <- as.data.frame(rotData)
names(rotData) <- c("indexX","indexY","indexZ")
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15, col = cols[cols$p==plane,]$color)
points3d(rotData, col = cols[cols$p==plane,]$color)
}
km.res[1,]
km.res[1,1:3]
atan2(km.res[1,1:3],km.res[2,1:3])
km.res[2,1:3]
as.numeric(km.res[2,1:3])
atan2(as.numeric(km.res[1,1:3]),as.numeric(km.res[2,1:3]))
theta.f
theta.t
atan2(as.numeric(km.res[1,1:3]),as.numeric(km.res[2,1:3]))*180/pi
theta <- atan2(as.numeric(km.res[1,1:3]),as.numeric(km.res[2,1:3]))
# dataset containing to-be-rotated fingers positions
rotData.backup <- testTrial[,c("indexX","indexY","indexZ")]
# starting dataset to apply translations and rotations on recursively
rotData <- rotData.backup
plot3d(rotData, col = "gray70")
##   1.1.3.1 find start and end of movement ----
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15)
# frontoparallel plane (x,y)
theta <- atan2(as.numeric(km.res[1,1:3]),as.numeric(km.res[2,1:3]))
theta.f = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexY[moment=="end"]-indexY[moment=="start"])))
# trasversal plane (x,z)
theta.t = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
# sagittal plane (y,z)
theta.s = with(km.res, atan2((indexY[moment=="end"]-indexY[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
theta.s*180/pi
# first we center the trajectory at start
# by translating by the centroids returned by the cluster analysis
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
transData <- transData[rep(1, nrow(rotData)),] # repeat for matrix substraction
rotData <- rotData.backup - transData # matrix subtraction
points3d(rotData)
cols <- data.frame(p = c("f","t","s"), color = c("red","blue","green"))
# this requires a three-steps rotation in 3D
for(plane in c("t","s"))
{
rotData <- switch(plane,
f = rotate3d(as.matrix(rotData), theta[1], 0, 0, 1),
t = rotate3d(as.matrix(rotData), theta[2], 0, 1, 0),
s = rotate3d(as.matrix(rotData), theta[3], 1, 0, 0)
)
rotData <- as.data.frame(rotData)
names(rotData) <- c("indexX","indexY","indexZ")
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15, col = cols[cols$p==plane,]$color)
points3d(rotData, col = cols[cols$p==plane,]$color)
}
# dataset containing to-be-rotated fingers positions
rotData.backup <- testTrial[,c("indexX","indexY","indexZ")]
# starting dataset to apply translations and rotations on recursively
rotData <- rotData.backup
plot3d(rotData, col = "gray70")
##   1.1.3.1 find start and end of movement ----
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15)
# frontoparallel plane (x,y)
theta <- atan2(as.numeric(km.res[1,1:3]),as.numeric(km.res[2,1:3]))
theta.f = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexY[moment=="end"]-indexY[moment=="start"])))
# trasversal plane (x,z)
theta.t = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
# sagittal plane (y,z)
theta.s = with(km.res, atan2((indexY[moment=="end"]-indexY[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
theta.s*180/pi
# first we center the trajectory at start
# by translating by the centroids returned by the cluster analysis
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
transData <- transData[rep(1, nrow(rotData)),] # repeat for matrix substraction
rotData <- rotData.backup - transData # matrix subtraction
points3d(rotData)
cols <- data.frame(p = c("f","t","s"), color = c("red","blue","green"))
# this requires a three-steps rotation in 3D
for(plane in c("t","s"))
{
rotData <- switch(plane,
f = rotate3d(as.matrix(rotData), theta[1], 0, 0, 1),
t = rotate3d(as.matrix(rotData), theta[3], 0, 1, 0),
s = rotate3d(as.matrix(rotData), theta[2], 1, 0, 0)
)
rotData <- as.data.frame(rotData)
names(rotData) <- c("indexX","indexY","indexZ")
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15, col = cols[cols$p==plane,]$color)
points3d(rotData, col = cols[cols$p==plane,]$color)
}
theta.t
theta
# dataset containing to-be-rotated fingers positions
rotData.backup <- testTrial[,c("indexX","indexY","indexZ")]
# starting dataset to apply translations and rotations on recursively
rotData <- rotData.backup
plot3d(rotData, col = "gray70")
##   1.1.3.1 find start and end of movement ----
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15)
# frontoparallel plane (x,y)
theta <- atan2(as.numeric(km.res[1,1:3]),as.numeric(km.res[2,1:3]))
theta.f = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexY[moment=="end"]-indexY[moment=="start"])))
# trasversal plane (x,z)
theta.t = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
# sagittal plane (y,z)
theta.s = with(km.res, atan2((indexY[moment=="end"]-indexY[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
theta.s*180/pi
# first we center the trajectory at start
# by translating by the centroids returned by the cluster analysis
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
transData <- transData[rep(1, nrow(rotData)),] # repeat for matrix substraction
rotData <- rotData.backup - transData # matrix subtraction
points3d(rotData)
cols <- data.frame(p = c("f","t","s"), color = c("red","blue","green"))
# this requires a three-steps rotation in 3D
for(plane in c("t","s"))
{
rotData <- switch(plane,
f = rotate3d(as.matrix(rotData), theta[1], 0, 0, 1),
t = rotate3d(as.matrix(rotData), theta[1], 0, 1, 0),
s = rotate3d(as.matrix(rotData), theta[1], 1, 0, 0)
)
rotData <- as.data.frame(rotData)
names(rotData) <- c("indexX","indexY","indexZ")
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15, col = cols[cols$p==plane,]$color)
points3d(rotData, col = cols[cols$p==plane,]$color)
}
# dataset containing to-be-rotated fingers positions
rotData.backup <- testTrial[,c("indexX","indexY","indexZ")]
# starting dataset to apply translations and rotations on recursively
rotData <- rotData.backup
plot3d(rotData, col = "gray70")
##   1.1.3.1 find start and end of movement ----
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15)
# frontoparallel plane (x,y)
theta <- atan2(as.numeric(km.res[1,1:3]),as.numeric(km.res[2,1:3]))
theta.f = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexY[moment=="end"]-indexY[moment=="start"])))
# trasversal plane (x,z)
theta.t = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
# sagittal plane (y,z)
theta.s = with(km.res, atan2((indexY[moment=="end"]-indexY[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
theta.s*180/pi
# first we center the trajectory at start
# by translating by the centroids returned by the cluster analysis
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
transData <- transData[rep(1, nrow(rotData)),] # repeat for matrix substraction
rotData <- rotData.backup - transData # matrix subtraction
points3d(rotData)
cols <- data.frame(p = c("f","t","s"), color = c("red","blue","green"))
# this requires a three-steps rotation in 3D
for(plane in c("t","s"))
{
rotData <- switch(plane,
f = rotate3d(as.matrix(rotData), theta[1], 0, 0, 1),
t = rotate3d(as.matrix(rotData), theta[2], 0, 1, 0),
s = rotate3d(as.matrix(rotData), theta[1], 1, 0, 0)
)
rotData <- as.data.frame(rotData)
names(rotData) <- c("indexX","indexY","indexZ")
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15, col = cols[cols$p==plane,]$color)
points3d(rotData, col = cols[cols$p==plane,]$color)
}
theta
theta <- atan2(as.numeric(km.res[km.res$moment=="start",1:3]),as.numeric(km.res[km.res$moment=="end",1:3]))
theta
# dataset containing to-be-rotated fingers positions
rotData.backup <- testTrial[,c("indexX","indexY","indexZ")]
# starting dataset to apply translations and rotations on recursively
rotData <- rotData.backup
plot3d(rotData, col = "gray70")
##   1.1.3.1 find start and end of movement ----
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15)
# frontoparallel plane (x,y)
(theta <- atan2(as.numeric(km.res[km.res$moment=="start",1:3]),as.numeric(km.res[km.res$moment=="end",1:3])))
# theta.f = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexY[moment=="end"]-indexY[moment=="start"])))
# # trasversal plane (x,z)
# theta.t = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
# # sagittal plane (y,z)
# theta.s = with(km.res, atan2((indexY[moment=="end"]-indexY[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
# first we center the trajectory at start
# by translating by the centroids returned by the cluster analysis
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
transData <- transData[rep(1, nrow(rotData)),] # repeat for matrix substraction
rotData <- rotData.backup - transData # matrix subtraction
points3d(rotData)
cols <- data.frame(p = c("f","t","s"), color = c("red","blue","green"))
# this requires a three-steps rotation in 3D
for(plane in c("t","s"))
{
rotData <- switch(plane,
f = rotate3d(as.matrix(rotData), theta[1], 0, 0, 1),
t = rotate3d(as.matrix(rotData), theta[2], 0, 1, 0),
s = rotate3d(as.matrix(rotData), theta[1], 1, 0, 0)
)
rotData <- as.data.frame(rotData)
names(rotData) <- c("indexX","indexY","indexZ")
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15, col = cols[cols$p==plane,]$color)
points3d(rotData, col = cols[cols$p==plane,]$color)
}
# dataset containing to-be-rotated fingers positions
rotData.backup <- testTrial[,c("indexX","indexY","indexZ")]
# starting dataset to apply translations and rotations on recursively
rotData <- rotData.backup
plot3d(rotData, col = "gray70")
##   1.1.3.1 find start and end of movement ----
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15)
# frontoparallel plane (x,y)
theta <- atan2(as.numeric(km.res[km.res$moment=="start",1:3]),as.numeric(km.res[km.res$moment=="end",1:3]))
theta*180/pi
# theta.f = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexY[moment=="end"]-indexY[moment=="start"])))
# # trasversal plane (x,z)
# theta.t = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
# # sagittal plane (y,z)
# theta.s = with(km.res, atan2((indexY[moment=="end"]-indexY[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
# first we center the trajectory at start
# by translating by the centroids returned by the cluster analysis
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
transData <- transData[rep(1, nrow(rotData)),] # repeat for matrix substraction
rotData <- rotData.backup - transData # matrix subtraction
points3d(rotData)
cols <- data.frame(p = c("f","t","s"), color = c("red","blue","green"))
# this requires a three-steps rotation in 3D
for(plane in c("t","s"))
{
rotData <- switch(plane,
f = rotate3d(as.matrix(rotData), theta[1], 0, 0, 1),
t = rotate3d(as.matrix(rotData), theta[2], 0, 1, 0),
s = rotate3d(as.matrix(rotData), theta[1], 1, 0, 0)
)
rotData <- as.data.frame(rotData)
names(rotData) <- c("indexX","indexY","indexZ")
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15, col = cols[cols$p==plane,]$color)
points3d(rotData, col = cols[cols$p==plane,]$color)
}
# dataset containing to-be-rotated fingers positions
rotData.backup <- testTrial[,c("indexX","indexY","indexZ")]
# starting dataset to apply translations and rotations on recursively
rotData <- rotData.backup
plot3d(rotData, col = "gray70")
##   1.1.3.1 find start and end of movement ----
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15)
# frontoparallel plane (x,y)
theta <- atan2(as.numeric(km.res[km.res$moment=="start",1:3]),as.numeric(km.res[km.res$moment=="end",1:3]))
theta*180/pi
# theta.f = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexY[moment=="end"]-indexY[moment=="start"])))
# # trasversal plane (x,z)
# theta.t = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
# # sagittal plane (y,z)
# theta.s = with(km.res, atan2((indexY[moment=="end"]-indexY[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
# first we center the trajectory at start
# by translating by the centroids returned by the cluster analysis
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
transData <- transData[rep(1, nrow(rotData)),] # repeat for matrix substraction
rotData <- rotData.backup - transData # matrix subtraction
points3d(rotData)
cols <- data.frame(p = c("f","t","s"), color = c("red","blue","green"))
# this requires a three-steps rotation in 3D
for(plane in c("t","s"))
{
rotData <- switch(plane,
f = rotate3d(as.matrix(rotData), theta[1], 0, 0, 1),
t = rotate3d(as.matrix(rotData), theta[2], 0, 1, 0),
s = rotate3d(as.matrix(rotData), theta[1], 1, 0, 0)
)
rotData <- as.data.frame(rotData)
names(rotData) <- c("indexX","indexY","indexZ")
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15, col = cols[cols$p==plane,]$color)
points3d(rotData, col = cols[cols$p==plane,]$color)
}
ifelse(theta < 0, theta + pi/2, theta)*180/pi
ifelse(theta < 0, theta + pi/2, theta)
ifelse(theta < 0, theta + pi/2, theta)
ifelse(theta < 0, theta + pi/2, theta)
ifelse(theta < 0, theta + pi/2, theta)
ifelse(theta < 0, theta + pi/2, theta)
theta
pi/2
theta[which(theta < 0)]
(theta[which(theta < 0)] <- theta[which(theta < 0)] + pi/2)*180/pi
theta
theta[which(theta < 0)] + pi/2
theta[which(theta < 0)] <- theta[which(theta < 0)] + pi/2
theta
theta <- atan2(as.numeric(km.res[km.res$moment=="start",1:3]),as.numeric(km.res[km.res$moment=="end",1:3]))
theta
rotData.backup <- testTrial[,c("indexX","indexY","indexZ")]
# starting dataset to apply translations and rotations on recursively
rotData <- rotData.backup
plot3d(rotData, col = "gray70")
##   1.1.3.1 find start and end of movement ----
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15)
# frontoparallel plane (x,y)
theta <- atan2(as.numeric(km.res[km.res$moment=="start",1:3]),as.numeric(km.res[km.res$moment=="end",1:3]))
theta[which(theta < 0)] <- theta[which(theta < 0)] + pi/2
theta
theta <- atan2(as.numeric(km.res[km.res$moment=="start",1:3]),as.numeric(km.res[km.res$moment=="end",1:3]))
theta
theta[which(theta < 0)]
theta[which(theta < 0)] + pi/2
theta <- atan2(as.numeric(km.res[km.res$moment=="start",1:3]),as.numeric(km.res[km.res$moment=="end",1:3]))
theta
theta <- atan2(as.numeric(km.res[km.res$moment=="start",1:3]),as.numeric(km.res[km.res$moment=="end",1:3]))
theta
theta[which(theta < 0)] <- theta[which(theta < 0)] + pi
theta
# dataset containing to-be-rotated fingers positions
rotData.backup <- testTrial[,c("indexX","indexY","indexZ")]
# starting dataset to apply translations and rotations on recursively
rotData <- rotData.backup
plot3d(rotData, col = "gray70")
##   1.1.3.1 find start and end of movement ----
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15)
# frontoparallel plane (x,y)
theta <- atan2(as.numeric(km.res[km.res$moment=="start",1:3]),as.numeric(km.res[km.res$moment=="end",1:3]))
theta[which(theta < 0)] <- theta[which(theta < 0)] + pi
theta
# theta.f = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexY[moment=="end"]-indexY[moment=="start"])))
# # trasversal plane (x,z)
# theta.t = with(km.res, atan2((indexX[moment=="end"]-indexX[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
# # sagittal plane (y,z)
# theta.s = with(km.res, atan2((indexY[moment=="end"]-indexY[moment=="start"]),(indexZ[moment=="end"]-indexZ[moment=="start"])))
# first we center the trajectory at start
# by translating by the centroids returned by the cluster analysis
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
transData <- transData[rep(1, nrow(rotData)),] # repeat for matrix substraction
rotData <- rotData.backup - transData # matrix subtraction
points3d(rotData)
cols <- data.frame(p = c("f","t","s"), color = c("red","blue","green"))
# this requires a three-steps rotation in 3D
for(plane in c("t","s"))
{
rotData <- switch(plane,
f = rotate3d(as.matrix(rotData), theta[1], 0, 0, 1),
t = rotate3d(as.matrix(rotData), theta[2], 0, 1, 0),
s = rotate3d(as.matrix(rotData), theta[1], 1, 0, 0)
)
rotData <- as.data.frame(rotData)
names(rotData) <- c("indexX","indexY","indexZ")
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15, col = cols[cols$p==plane,]$color)
points3d(rotData, col = cols[cols$p==plane,]$color)
}
theta*180/pi
# dataset containing to-be-rotated fingers positions
rotData.backup <- testTrial[,c("indexX","indexY","indexZ")]
# starting dataset to apply translations and rotations on recursively
rotData <- rotData.backup
plot3d(rotData, col = "gray70")
##   1.1.3.1 find start and end of movement ----
# case unknown
# rationale: there will be many more samples around start and end of movement
# because of the low speed of motion
# hence the distribution of x, y and z positions should be highly bimodal
# we use cluster analysis to find the centroids of the two clusters (start & end)
# of each position of each finger
kmData <- cbind(rotData, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
print(km.res)
points3d(km.res[1:3], size = 15)
# frontoparallel plane (x,y)
theta <- atan2(as.numeric(km.res[km.res$moment=="start",1:3]),as.numeric(km.res[km.res$moment=="end",1:3]))
theta[which(theta < 0)] <- theta[which(theta < 0)] + pi
theta*180/pi
