# set velocity threshold
returnVel_threshold <- -100
# crop
trialData <- subset(trialData, thumbZvel > returnVel_threshold & indexZvel > returnVel_threshold)
#### onset time
# set velocity threshold
onsetVel_threshold <- 100
# find onset frame
onsetFrame <- kin.find.onsetTime(trialData$thumbVel, onsetVel_threshold)
# crop trajectory before onset
trialData <- subset(trialData, frameN >= onsetFrame)
#### offset time
# heuristic based on resultant vector of vel,acc,jerk
# calculate jerk
trialData$indexJerk <- kin.sgFilter(kin.sgFilter(trialData$indexVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
trialData$thumbJerk <- kin.sgFilter(kin.sgFilter(trialData$thumbVel, m = 1, ts = refreshRate), p = 12, ts = refreshRate)
# resultant vectors
trialData$thumbVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$indexVelAccJerk.res <- with(trialData, sqrt(thumbVel^2 + thumbAcc^2 + thumbJerk^2))
trialData$index_thumbVelAccJerk.res <- with(trialData, sqrt(thumbVelAccJerk.res^2 + indexVelAccJerk.res^2))
# z distance after rotation
ztheor <- round(kin.rotate.trajectory(as.data.frame(t(end-start)), end-start), 2)[3]
# we look for the offset frame in the second half of the trajectory
offsetFrame <- with(subset(trialData, thumbZ > ztheor/2),
frameN[match(kin.min(index_thumbVelAccJerk.res), index_thumbVelAccJerk.res)])
# crop trajectory after offset
trialData <- subset(trialData, frameN <= offsetFrame)
#### space normalization
# euclidean distance of thumb to its final position
trialData$thuDist <- sqrt((trialData$thumbX - tail(trialData$thumbX, 1))^2 +
(trialData$thumbY - tail(trialData$thumbY, 1))^2 +
(trialData$thumbZ - tail(trialData$thumbZ, 1))^2
)
# bin thuDist
binN <- 100
trialData$thuDistB <- with(trialData, cut(thuDist, breaks = binN, labels = F))
#### grasp analysis
graspData <- kin.grasp.analysis(data = trialData, signals = c("index","thumb"), deltaTime = refreshRate)
#### merge reaching and grasp analysis
trialData <- cbind(trialData, graspData)
#### other specs
trialData$objectZ <- ifelse(end[3] > -300, 270, 350)
#### append trajectory data to main trajectory dataset
trajData <- rbind(trajData, trialData)
#### extract parameters
extractData <- kin.extract.parameters(trialData, c("index","thumb"), grasp = T)
#### append reach parameters to main dataset
trialParams.r <- extractData$reach_parameters
trialParams.r$trialN <- tN
reach_paramData <- rbind(reach_paramData, trialParams.r)
#### append reach parameters to main dataset
trialParams.g <- extractData$grasp_parameters
trialParams.g$trialN <- tN
grasp_paramData <- rbind(grasp_paramData, trialParams.g)
#### append time info to main dataset
timeinfoParams <- extractData$time_info
timeinfoParams$trialN <- tN
timeinfoData <- rbind(timeinfoData, timeinfoParams)
}
head(reach_paramData)
head(grasp_paramData)
head(timeinfoData)
#### Results ####
unique(trajData$trialN)
#### Results ####
ggplot(data = trajData) +
geom_point(aes(indexX, indexZ), color = "red") +
geom_point(aes(thumbX, thumbZ), color = "blue") +
facet_grid(. ~ objectZ) +
coord_fixed()
ggplot(data = trajData) +
geom_point(aes(-thuDist, indexZ), color = "red") +
geom_point(aes(-thuDist, thumbZ), color = "blue") +
facet_grid(. ~ objectZ)
ggplot(aes(trialN, movTime), data = timeinfoData) + geom_point()
ggplot(aes(trialN, MdeviationX, color = signal), data = reach_paramData) + geom_point() + geom_smooth(method = lm)
ggplot(aes(trialN, MdeviationY, color = signal), data = reach_paramData) + geom_point() + geom_smooth(method = lm)
ggplot(data=trajData) +
geom_point(aes(time, GOF*180/pi, color = objectZ))
ggplot(data=trajData) +
geom_point(aes(time, GOT*180/pi, color = objectZ))
ggplot(data=trajData) +
geom_point(aes(time, GOS*180/pi, color = objectZ))
# original 3D signal
signal <- rtgData_bad[rtgData_bad$trialN==50, c("thumbXraw","thumbYraw","thumbZraw")]
# parameters
signal.name <- "thumb"
start <- c(267,-332,-11.5)
end <- c(34.8,-53.4,-283)
refreshRate <- 1/85
kin.signal.analysis <- function(signal, signal.name = "signal", start, end, maxFrames = 20, deltaTime)
{
# make backup
signal.backup <- signal
# name of signal
names(signal) <- paste(signal.name, c("X","Y","Z"), "raw", sep = "")
# repair
signalRep <- as.data.frame(apply(signal, 2, kin.signal.repair, maxFrames = maxFrames))
names(signalRep) <- paste(signal.name, c("X","Y","Z"), "rep", sep = "")
# filter
signalSG <- as.data.frame(apply(signalRep, 2, kin.sgFilter, ts = deltaTime))
names(signalSG) <- paste(signal.name, c("X","Y","Z"), "sg", sep = "")
# translate
M <- matrix(rep(start, nrow(signalSG)), ncol = 3, byrow = T) # replicate origin to create a dataset to subtract to the signal
signalTra <- as.data.frame(signalSG - M) # translate
names(signalTra) <- paste(signal.name, c("X","Y","Z"), "tra", sep = "")
# rotate
signalRot <- as.data.frame(kin.rotate.trajectory(signalTra, end - start))
names(signalRot) <- paste(signal.name, c("X","Y","Z"), "rot", sep = "")
# vel, acc
signalVel <- as.data.frame(apply(signalRot, 2, kin.sgFilter, m=1, ts = deltaTime)) # 3D velocities
names(signalVel) <- paste(signal.name, c("X","Y","Z"), "vel", sep = "")
signalVel$vel_temp <- kin.sgFilter(sqrt(signalVel[,1]^2 + signalVel[,2]^2 + signalVel[,3]^2), ts = deltaTime)
signalVel$acc_temp <- kin.sgFilter(kin.sgFilter(signalVel$vel_temp, m = 1, ts = deltaTime), p = 12, ts = deltaTime)
names(signalVel)[4:5] <- paste(signal.name, c("Vel","Acc"), sep = "")
# merge
signal <- cbind(signalRot, signalVel)
names(signal)[1:3] <- paste(signal.name, c("X","Y","Z"), sep = "")
return(signal)
}
head(signal)
head(kin.signal.analysis(signal, "thumb", start, end, deltaTime = refreshRate, returnVel_threshold = return_threshold))
head(kin.signal.analysis(signal, "thumb", start, end, deltaTime = refreshRate))
?kin.signal.analysis
?kin.signal.analysis
kin.signal.analysis
#### set working directory ####
this_file_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(this_file_dir)
#### set working directory ####
this_file_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(this_file_dir)
#### DATASET PREPARATION ####
# common
source("./sample_specs.R")
# motor trajectories
source("./perc_motor_comparison_files/load-save_dataAIM.R")
source("./perc_motor_comparison_files/load-save_dataCLAMP.R")
trialParams.g
head(trajData.aim)
trajData.aim$handZB <- with(trajData.aim, cut(handZ, breaks = 100, labels = F))
testData <- ddply(trajData.aim, .(pairN, rotation, handZB), summarise,
handX = mean(handX, na.rm=T),
handZ = mean(handZ, na.rm=T))
testData <- ddply(trajData.aim, .(pairN, rotation, session, handZB), summarise,
handX = mean(handX, na.rm=T),
handZ = mean(handZ, na.rm=T))
ggplot(aes(handX, handZ, color = session), data = testData) +
geom_point() +
facet_grid(pairN ~ rotation)
ggplot(aes(handX, handZ, color = session), data = testData) +
geom_point() +
facet_grid(pairN ~ rotation) +
coord_fixed()
ggplot(aes(handX, handZ, color = session), data = testData) +
geom_point() +
geom_hline(yintercept = .1) +
geom_vline(xintercept = .1) +
facet_grid(pairN ~ rotation) +
coord_fixed()
geom_vline(xintercept = c(-.1,.1) +
)
)
ggplot(aes(handX, handZ, color = session), data = testData) +
geom_point() +
geom_hline(yintercept = .1) +
geom_vline(xintercept = c(-.1,.1)) +
facet_grid(pairN ~ rotation) +
coord_fixed()
trajData.clamp$handZB <- with(trajData.clamp, cut(handZ, breaks = 100, labels = F))
testData <- ddply(trajDattrajData.clampa.aim, .(pairN, rotation, session, handZB), summarise,
handX = mean(handX, na.rm=T),
handZ = mean(handZ, na.rm=T))
testData <- ddply(trajData.clamp, .(pairN, rotation, session, handZB), summarise,
handX = mean(handX, na.rm=T),
handZ = mean(handZ, na.rm=T))
ggplot(aes(handX, handZ, color = session), data = testData) +
geom_point() +
geom_hline(yintercept = .1) +
geom_vline(xintercept = c(-.1,.1)) +
facet_grid(pairN ~ rotation) +
coord_fixed()
write.table(trajData.aim, file = "c:/Users/carlo/Desktop/GitHub/kinesis/data/reachData.txt",
quote = F, row.names = F)
unique(trajData.aim$subjName)
reachData <- subset(trajData.aim, subjName == "cc1")
write.table(reachData, file = "c:/Users/carlo/Desktop/GitHub/kinesis/data/reachData.txt",
quote = F, row.names = F)
#### Prepare the dataset ####
# keep only useful columns
usefCols <- c("trialN","indexXraw","indexYraw","indexZraw")
# check dataset
testData <- data.check(reachData[usefCols])
#### Prepare the dataset ####
# keep only useful columns
usefCols <- c("trialN","handX","handZ")
# check dataset
testData <- data.check(reachData[usefCols])
#### main dataset
trajData <- NULL
reach_paramData <- NULL
timeinfoData <- NULL
#### Analysis loop ####
trialsList <- unique(testData$trialN)
trialsList
tN <- trialsList[1]
# tN <- trialsList[1]
cat("---- trial #", tN, ". ----\n\n", sep = "")
#### select trial ----
testTrial <- subset(testData, trialN == tN)
#### signals analysis ----
# set start x y z coordinates ----
start <- c(0, 0, 0)
head(testTrial)
head(reachData)
endx <- ifelse(is.na(rotation), 0, .1*(tan(rotation*pi/180)))
endx <- with(testTrial, ifelse(is.na(rotation), 0, .1*(tan(rotation*pi/180))))
head(testTrial)
#### Prepare the dataset ####
# keep only useful columns
usefCols <- c("trialN","handX","handZ","rotation")
# check dataset
testData <- data.check(reachData[usefCols])
#### main dataset
trajData <- NULL
reach_paramData <- NULL
timeinfoData <- NULL
# tN <- trialsList[1]
cat("---- trial #", tN, ". ----\n\n", sep = "")
#### select trial ----
testTrial <- subset(testData, trialN == tN)
#### signals analysis ----
# set start x y z coordinates ----
start <- c(0, 0, 0)
head(testTrial)
endx <- with(testTrial, ifelse(is.na(rotation), 0, .1*(tan(rotation*pi/180))))
endx
end <- c(endx, .1)
# refresh rate ----
refreshRate <- 1/85
# prepare signals datasets
hand.signal <- testTrial[,c("handX","handZ")]
# analysis: repair, filter, translate, rotate ----
indexData <- kin.signal.analysis(index.signal, "hand", start, end, deltaTime = refreshRate)
# analysis: repair, filter, translate, rotate ----
indexData <- kin.signal.analysis(hand.signal, "hand", start, end, deltaTime = refreshRate)
?kin.signal.analysis
kin.signal.analysis
# prepare signals datasets
testTrial$handY <- 0
hand.signal <- testTrial[,c("handX","handY","handZ")]
# analysis: repair, filter, translate, rotate ----
indexData <- kin.signal.analysis(hand.signal, "hand", start, end, deltaTime = refreshRate)
hand.signal
end <- c(endx, 0, .1)
# analysis: repair, filter, translate, rotate ----
handData <- kin.signal.analysis(hand.signal, "hand", start, end, deltaTime = refreshRate)
hand.signal
start
end
# analysis: repair, filter, translate, rotate ----
handData <- kin.signal.analysis(hand.signal, "hand", start, end, deltaTime = refreshRate)
kin.signal.analysis
options(scipen = 1, digits = 3)
library(cowplot)
#### Prepare the dataset ####
# keep only useful columns
usefCols <- c("trialN","indexXraw","indexYraw","indexZraw","thumbXraw","thumbYraw","thumbZraw")
# Fix dataset
testData <- data.check(rtgData_bad[usefCols])
# select one trial with missing frames
testTrial <- subset(testData, trialN == 50)
# repair missing frames
testTrial$indexXrep <- with(testTrial, kin.signal.repair(indexXraw, maxFrames= 20))
testTrial$indexYrep <- with(testTrial, kin.signal.repair(indexYraw, maxFrames= 20))
testTrial$indexZrep <- with(testTrial, kin.signal.repair(indexZraw, maxFrames= 20))
testTrial$thumbXrep <- with(testTrial, kin.signal.repair(thumbXraw, maxFrames= 20))
testTrial$thumbYrep <- with(testTrial, kin.signal.repair(thumbYraw, maxFrames= 20))
testTrial$thumbZrep <- with(testTrial, kin.signal.repair(thumbZraw, maxFrames= 20))
#    1.1.2.2 Savitzky-Golay filter ----
# 3rd order
testTrial$indexXsg <- with(testTrial, kin.sgFilter(indexXrep, ts = 1/85))
testTrial$indexYsg <- with(testTrial, kin.sgFilter(indexYrep, ts = 1/85))
testTrial$indexZsg <- with(testTrial, kin.sgFilter(indexZrep, ts = 1/85))
testTrial$thumbXsg <- with(testTrial, kin.sgFilter(thumbXrep, ts = 1/85))
testTrial$thumbYsg <- with(testTrial, kin.sgFilter(thumbYrep, ts = 1/85))
testTrial$thumbZsg <- with(testTrial, kin.sgFilter(thumbZrep, ts = 1/85))
testTrial$indexX <- testTrial$indexXsg
testTrial$indexY <- testTrial$indexYsg
testTrial$indexZ <- testTrial$indexZsg
testTrial$thumbX <- testTrial$thumbXsg
testTrial$thumbY <- testTrial$thumbYsg
testTrial$thumbZ <- testTrial$thumbZsg
# starting dataset to apply translations and rotations on recursively
indData.backup <- testTrial[,c("indexX","indexY","indexZ")]
thuData.backup <- testTrial[,c("thumbX","thumbY","thumbZ")]
# dataset containing to-be-rotated fingers positions
rotData.backup <- rbind(indData.backup, setNames(thuData.backup, names(indData.backup)))
# CASE 1: whole grasp
kmData <- cbind(rotData.backup, time = testTrial[,"time"])
km.res <- as.data.frame(kmeans(kmData, 2)$centers)
km.res$moment <- with(km.res, ifelse(time == min(time), "start", "end"))
# translate the trajectory to origin (0,0,0)
transData <- km.res[km.res$moment=="start", !names(km.res)%in%c("time","moment")] # getting the centroids
# matrix subtraction
rotData <- rotData.backup - transData[rep(1, nrow(rotData.backup)),]
indData <- indData.backup - transData[rep(1, nrow(indData.backup)),]
thuData <- thuData.backup - transData[rep(1, nrow(thuData.backup)),]
# end coordinates of the whole grasp
end <- as.numeric(km.res[km.res$moment=="end",1:3] - km.res[km.res$moment=="start",1:3]) # centered end coordinates
# rotate trajectories
indData <- kin.rotate.trajectory(indData, end)
thuData <- kin.rotate.trajectory(thuData, end)
# polish rotated dataset
indData <- as.data.frame(indData)
names(indData) <- c("indexX","indexY","indexZ")
thuData <- as.data.frame(thuData)
names(thuData) <- c("thumbX","thumbY","thumbZ")
plot3d(rotData[c(1,3,2)])
points3d(indData[c(1,3,2)], col="red")
points3d(thuData[c(1,3,2)], col="blue")
#### Prepare the dataset ####
# keep only useful columns
usefCols <- c("trialN","handX","handZ","rotation")
# Fix dataset
testData <- data.check(reachData[usefCols])
#### Prepare the dataset ####
# keep only useful columns
usefCols <- c("subjName","trialN","handX","handZ","rotation")
# Fix dataset
testData <- data.check(reachData[usefCols])
# Fix dataset
testData <- data.check(reachData)
# Fix dataset
head(reachData)
reqColumns
### setting dataset columns ----
# five columns are expected
get("dataCols", kinesis_parameters)
#### Prepare the dataset ####
# five columns are expected
get("dataCols", kinesis_parameters)
#### Prepare the dataset ####
# five columns are expected
get("dataCols", kinesis_parameters)
# user can set them
kin.setDataCols(deltaTime = "refreshRate")
#### Prepare the dataset ####
# five columns are expected
get("dataCols", kinesis_parameters)
get("dataCols", kinesis_parameters)
# Fix dataset
testData <- data.check(reachData)
# select one trial with missing frames
testTrial <- subset(testData, trialN == 50)
# testTrial <- subset(testData, trialN == badTrialNum)
# plot the data
ggplot(aes(frameN, thumbXraw), data = testTrial) + geom_point() # thumb data is bad
# testTrial <- subset(testData, trialN == badTrialNum)
# plot the data
ggplot(aes(frameN, handX), data = testTrial) + geom_point() # thumb data is bad
# testTrial <- subset(testData, trialN == badTrialNum)
# plot the data
ggplot(aes(frameN, handX), data = testTrial) + geom_point() # handX data is good
# repair missing frames
testTrial$handXrep <- with(testTrial, kin.signal.repair(handX, maxFrames= 20))
testTrial$handZrep <- with(testTrial, kin.signal.repair(handZ, maxFrames= 20))
testTrial$handZrep
##   1.1.2 filter ----
#    Savitzky-Golay filter ----
# 3rd order
testTrial$handXsg <- with(testTrial, kin.sgFilter(handXrep, ts = refreshRate))
testTrial$handZsg <- with(testTrial, kin.sgFilter(handZrep, ts = refreshRate))
ggplot(data = testTrial) +
geom_point(aes(frameN, handXrep), color = "black") +
geom_point(aes(frameN, handXsg), color = "green", alpha=.5)
#    1.2.2.1 apply filter ----
testTrial$handX <- testTrial$handXsg
testTrial$handZ <- testTrial$handZsg
# original 3D signal
head(reachData)
# original 3D signal
signal <- reachData[reachData$trialN==50, c("handX","handZ")]
# original 3D signal
signal <- reachData[reachData$trialN==50, c("handX","handZ")]
# parameters
signal.name <- "hand"
start <- c(0,0,0)
end <- c(0,0,.1)
# original 3D signal
signal <- reachData[reachData$trialN==50, c("handX","handZ","refreshRate")]
# parameters
signal.name <- "hand"
start <- c(0,0,0)
end <- c(0,0,.1)
deltaTime <- signal$refreshRate
# make backup
signal.backup <- signal
# name of signal
names(signal) <- paste(signal.name, c("X","Y","Z"), "raw", sep = "")
names(signal)
# make backup
signal.backup <- signal
# check what columns match the signal name
names(signal)
# original 3D signal
signal <- reachData[reachData$trialN==50, c("handX","handZ","refreshRate")]
# parameters
signal.name <- "hand"
start <- c(0,0,0)
end <- c(0,0,.1)
deltaTime <- signal$refreshRate
# make backup
signal.backup <- signal
# check what columns match the signal name
names(signal)
names(signal) %in% "hand"
# check what columns match the signal name
grepl(signal.name, names(signal))
?find()
# check what columns match the signal name
names(signal)[grepl(signal.name, names(signal))]
# check what columns match the signal name
names(signal)[grepl(signal.name, names(signal))]
# name of signal
names(signal) <- paste0(signal.name, c("X","Y","Z"), "raw")
# check what columns match the signal name
names(signal)[grepl(signal.name, names(signal))]
# original 3D signal
signal <- reachData[reachData$trialN==50, c("handX","handZ","refreshRate")]
# parameters
signal.name <- "hand"
start <- c(0,0,0)
end <- c(0,0,.1)
deltaTime <- signal$refreshRate
# make backup
signal.backup <- signal
# check what columns match the signal name
names(signal)[grepl(signal.name, names(signal))]
# check what columns match the signal name
signalCols <- names(signal)[grepl(signal.name, names(signal))]
length(signalCols) < 3
paste0(signal.name, c("X","Y","Z"))
expectedCols <- paste0(signal.name, c("X","Y","Z"))
names(signal)[grepl(expectedCols, names(signal))]
for(col in expectedCols)
names(signal)[grepl(col, names(signal))]
names(signal)[grepl(col, names(signal))]
col
names(signal)[grepl("handY", names(signal))]
length(names(signal)[grepl("handY", names(signal))])
for(col in expectedCols)
{
cat(length(names(signal)[grepl(col, names(signal))]), "\n")
}
signal <- rbind(signal, 0)
signal
# original 3D signal
signal <- reachData[reachData$trialN==50, c("handX","handZ","refreshRate")]
# parameters
signal.name <- "hand"
start <- c(0,0,0)
end <- c(0,0,.1)
deltaTime <- signal$refreshRate
# make backup
signal.backup <- signal
# check what columns match the signal name
signalCols <- names(signal)[grepl(signal.name, names(signal))]
# if one column is missing, set it to zero
if(length(signalCols) == 2)
{
# expected columns
expectedCols <- paste0(signal.name, c("X","Y","Z"))
for(col in expectedCols)
{
isColFound <- length(names(signal)[grepl(col, names(signal))])>0
if(!isColFound)
signal <- cbind(signal, 0)
}
}
head(signal)
col
# original 3D signal
signal <- reachData[reachData$trialN==50, c("handX","handZ","refreshRate")]
# parameters
signal.name <- "hand"
start <- c(0,0,0)
end <- c(0,0,.1)
deltaTime <- signal$refreshRate
# make backup
signal.backup <- signal
# check what columns match the signal name
signalCols <- names(signal)[grepl(signal.name, names(signal))]
# if one column is missing, set it to zero
if(length(signalCols) == 2)
{
# expected columns
expectedCols <- paste0(signal.name, c("X","Y","Z"))
for(col in expectedCols)
{
isColFound <- length(names(signal)[grepl(col, names(signal))])>0
if(!isColFound)
{
signal <- cbind(signal, 0)
names(signal)[length(names(signal))] <- col
}
}
}
head(signal)
# reorder columns
signalCols <- names(signal)[grepl(signal.name, names(signal))]
signalCols
